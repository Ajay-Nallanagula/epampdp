#region Previous
Install typescript means install its compiler "tsc"
either globally or locally

https://www.typescriptlang.org/download

tsconfig.json:
https://www.typescriptlang.org/docs/handbook/tsconfig-json.html

compiler options: {
allowJs, checkJs is used to add ts to exisiting javascript projects
noEmit : https://www.typescriptlang.org/tsconfig#noEmit
}

SOLID: https://blog.bitsrc.io/solid-principles-in-typescript-153e6923ffdb
        https://samueleresca.net/solid-principles-using-typescript/ 
#endregion Previous

TypeScript is a free and open-source programming language developed and maintained by Microsoft. 
It is a strict syntactical superset of JavaScript, and adds optional static typing and class-based object-oriented programming to the language.

Optional Static Typing: 
Static typing means that the type of a variable is known at compile-time instead of at runtime. For instance, once a variable is declared to be of a certain type in a statically typed language, it cannot be reassigned to a different type later.

//Static Typing : the variables 'name' and 'age' can only hold string and number data types respectively.
let name: string = 'John Doe';
let age: number = 30;
name2 =100 //Type 'number' is not assignable to type 'string'

//Dynamic typing:  TypeScript's type inference still allows it to understand that 'name' is a string and 'age' is a number. We can now freely change the types of //'name' and 'age' at any point
let name:any = 'John Doe';
let age:any = 30;
name2 =1000 //Dynamically assigned a number

Default access specifier in Typescript is public 
Type is Typescript : number,boolean,string, null,undefined,object,array, enum,tuple, any, unknown, never

Tuple Vs Array :
===============
--> Tuple is fixed size, array is dynamic size.
a tuple is an array with fixed size and known datatypes. This is to say; youâ€™d use a tuple for a static, well-defined array.
const primaryColors: [string, string, string] = ['red', 'blue', 'green'];
const primaryColors: [string, string] = ['red', 'blue', 'green']; //Error, an extra string
const primaryColors: [string, string, string] = ['red', 'blue']; //Error, missed an item
Array :  No fixed size .
const primaryColors: string[] = ['#ff0000', '#00ff00', '#0000ff'];

--> Tuple and Arrays both can store differnt data types , but in Tuples order have to preserved
let tup: [string,boolean]  = ['apple',true] //Error if [false,'Orange']
let arr:(string|number)[] = ['Apple',10] or [10,'Apple]

Union Type : let val: (number|string|boolean|tupele) = /* Can be given any defined types here*/ etc "|" is a symbol of union type
Type aliases: type MixedTypes = number|string|boolean , this is a utility like from typescript , where you can your code more readable
let val: MixedTypes .
Type aliase can also be used with objects like 
type User = { name: string; age: number };
const u1: User = { name: 'Max', age: 30 }; // this works!
type User = { name: string; age: number };
 
function greet(user: User) {
  console.log('Hi, I am ' + user.name);
}

#region TS functions, type "Function"

let someVal:undefined //Valid statement, undefined is a type in TS 
//Warning error , this is not possible unless you return undefined from function
function someFunction():undefined{ return; //If not returned error/warning} 
function someFunction():void{}  In this case we don't have to return anything.

let call:Function = () => {} //Valid statement
call = 100 //error , call should be a Function 
Function may not be that useful, because any function can be assigned to call,you cannot handle specificity

So we can use Funtions type with lambda notation 
const call:(num:number,num:number)=>num
const call2:(num:number,str:string) => []:<ArrayTypr> //or array of some type 
const call3:(str:string,isCorrect:bool)=> {}:<ObjectType> //or Object of some type 
Eg:
type func = (num: number, num2: number) => number[];
    let func2: func = (num1, num2) => [num1, num2];
    console.log(func2(30, 4));

#endregion TS functions

#region unknown,never,any
--> unknown is like any, with few restrictions 
let name2:unknown
let username:string
	name2 ='Ajay';
	username = name2; //ERROR type 'unknown' is not assignable to type 'string'
//To avoid this we can We have to prove TS that name2 is string, 
 if(typeof name2 === 'string'){ username = name2; } //Now this is VALID

Now consider the same case with any 
let name2: any;
let username: string;
name2 ='Ajay';
username = name2; // Any has no restrictions , VALID , NO-ERROR

Never :
//such functions are Common to construct error messages 
function giveError(): never{
//The function never returns in this case hence never
	throw new Error('This is an error') 
}

function giveError(some_params): never{
//The function never return in this case hence never
infiniteLoop....
while(true){}
}


#endregion unknown,never,any

#region Type Guards
Type Guards: checking if a property exists in object, a method in the function 
if("isProp" in exampleObj){console.log(exampleObj.isProp)}
if("isFunc" in exampleObj){console.log(exampleObj.isFunc()} 
if(obj instanceOf exampleObj) {console.log(Obj.isFunc()}

#endregion Type Guards

#region Interfaces

interface Animal {
readonly prop:string
    petName: number | string;
    noOfLegs: number;
	greet:(name:string) =>void;
}

Interface properties are public by default, you cannot add access-modifiers in interface.EXCEPT readonly
Readonly property can be assigned inside a constructor or at intialization

class Pashu extends Animal{
 ctor(name:string){
	this.prop = name //from interface
 }
}

const p = new Pashu()
p.prop //Error its a readonly property from Interface 

--> Interface can extends other Interface
InterfaceA extends InterfaceB

Optional Interfaces 
interface Animal {
readonly prop:string
    petName: number | string;
    noOfLegs?: number; //Optional Property class need not implement property noOfLegs
	greet?:(name:string) =>void; //Optional function, Class Need not implement this 
}


How are Interfaces represented in Javascript when compiled?
When TS code is compiled to JS , Interfaces will not be there in JS files. Javascript has no concept of Interfaces
Interfaces are only during developmemnt to write correct code, JS files there will not be any construct for Interfaces.


#endregion Interfaces 

#region Type Vs Interface:
In Detail: https://blog.logrocket.com/types-vs-interfaces-typescript/
--> Interfaces are used for Object definitions , They cannot be used for Unions and Intersection of types, for such cases we will have to use Type
--> Interface can be implemented by a class, Its like a contract. Where as type has no such restrictions.
--> Interfaces with the same name in the same scope merge their declarations, leading to unexpected bugs.
			Eg: //Inside interface demo.js
			interface User {   name: string; }
			interface User {   id: string; }
			const user: User = {
			//ERROR: Property 'name' is missing in type '{ id: string; }' but required in type 'User'.
			  id: "123",
			};

			//Inside typeDemo.js
			type User {   name: string; }
			type User {   id: string; } //ERROR: DUPLICATE IDENTIFIER DECLARED
			
--> Extends Vs Intersection 
// We can combine two interfaces to create intersection type but cannot create intersection interfaces
interface PersonNameInterface { name: string; }
interface PersonAgeInterface { age: number; }
type Person3 = PersonNameInterface & PersonAgeInterface //Valid Code

type t1 =number | string
type t2 = number|boolean
type t3=  t1&t2 //Valid code & is intersection 

When it comes to Union
A class can only implement an object type or intersection of object types with statically known members.
Eg: 
interface Animal {
    petName: number | string;
    noOfLegs: number;
}

interface RDB {
    petName2: number | string;
    noOfLegs4: number;
}

type AnimalRDB = Animal | RDB;

class InterfaceDemo implements AnimalRDB { Error : A class can only implement an object type or intersection of object types with statically known members.
    petName: string | number;

Types also can be extended:
type PersonNameType = { name: string }
interface Person2 extends PersonNameType { age: number }

Use interfaces when:

A new object or an object method needs to be defined.
You wish to benefit from declaration merging.
Use types when:

You need to define a primitive-type alias
Defining tuple types
Defining a union
You must create functions and attempt to overload them in object types through composition.
Requiring the use of mapped types

#endregion Type Vs Interface

#region Generics

Generics are code templates that you can define and reuse throughout your codebase. They provide a way to tell functions, classes, or interfaces what type you want to use when you call it.

Array in TS is generic type 
let arr:Array<string> = ['a','b']

Promise in TS is a generic Type: 
const promise: Promise<string> = new Promise((resolve,reject) => {
	setTimeout(() =>resolve('DONE'),3000) //the type returned here by resolve is string .
})

promise.then(data => {}) //type of 'data' here will string

Consider the below scenario :
=============================
function merge(objA: object, objB: object) {
    return Object.assign({},objA, objB);
}
const mergedObj = merge({name:'Ajay'},{id:100});
//intellisense will not work here, strong typing is non-existent
mergedObj.name
 intersection of two unkonwn objects is another unknown object

To overcome this We can use generics 
function merge<T,U>(objA: T, objB: U): T & U {
    return Object.assign({},objA, objB);
}
//mergedObj contain a specific type T and Specific type U
const mergedObj = merge({ name: 'Ajay' }, { id: 100 });
mergedObj.name; //This works now.
 /*Below statement  is valid statement, output will be nothing because they are not objects , object. assign will not complain, will fail silently*/
 const m2 = merge<string,number>('Ajay',10)

Generic Constraints
====================
https://www.typescriptlang.org/docs/handbook/utility-types.html#extracttype-union
Constraints enhance generic functionality.

function merge<T extends object,U extends object>(objA: T, objB: U) {
    return Object.assign({},objA, objB);
}
//Error because T and U must be objects here , added constraints 
const m2 = merge<string,number>('Ajay',10) 

function extractAndConvert<T extends object, U extends keyof T>(obj: T, key: U) {
    return obj[key];
}
extractAndConvert({namekey:'Ajay'}, 'namekey');

Examples of constraints :
merge<T extends string | number | boolean>()

Generic Utility Functions
==========================
Partial: Make the properties of an object optional
---------------------------------------------------
Example :
type CourseGoal = {
    name: string; description: string; courseFee: number;
};

const fillGoal = (name: string, desc: string, fee: number): CourseGoal => {
    
    //Below line will emit error because ,
    //the object is empty and its type is CourseGoal which cannot have empty values nor is optional
    //let coursegoal: CourseGoal = {};

    //To temporarirly make CourseGoal props optional we can use Partial<T> generic utility.
    let coursegoal: Partial<CourseGoal> = {};

    coursegoal.name = 'Ajay';
    coursegoal.description = 'xxxxx';
    coursegoal.courseFee = 100;
    return coursegoal as CourseGoal;
};


NonNullable<Type>
=================
type T0 = NonNullable<string | number | undefined>;
type T0 = string | number
type T1 = NonNullable<string[] | null | undefined>;
type T1 = string[]

Required<Type>
===============
Constructs a type consisting of all properties of Type set to required. The opposite of Partial.

Example
interface Props {
  a?: number;
  b?: string;
}
 
const obj: Props = { a: 5 };
 
const obj2: Required<Props> = { a: 5 };
Property 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'.


Readonly 
---------
//Make the array constant, you don't need any changes to it
//const arr = ['A', 'B'];
//We can us ReadOnly
const arr: Readonly<string[]> = ['A', 'B'];
arr.push('C'); //Error, arr is Readonly
arr.pop(); //Error, arr is Readonly

Pick<Type, Keys>
=================
Constructs a type by picking the set of properties Keys (string literal or union of string literals) 
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}
 
type TodoPreview = Pick<Todo, "title" | "completed">;
 
const todo: TodoPreview = {
  title: "Clean room",
  completed: false,
};

Omit<Type, Keys>
==================
Constructs a type by picking all properties from Type and then removing Keys (string literal or union of string literals).
interface Todo {
  title: string;
  description: string;
  completed: boolean;
  createdAt: number;
}
 
type TodoPreview = Omit<Todo, "description">;
 
const todo: TodoPreview = {
  title: "Clean room",
  completed: false,
  createdAt: 1615544252770,
};


type TodoInfo = Omit<Todo, "completed" | "createdAt">;
 
//Both completed and CreatedAt can be Omitted
const todoInfo: TodoInfo = {
  title: "Pick up kids",
  description: "Kindergarten closes at 5pm",
};


Generic Vs UnionType
=====================
//With Union  Consider below scenario 
class Storage {
    data: string[] | number[] | boolean[] = [];

//Error , we cannot add item because data can be any array
//if array is number, item can be string and other possibilites 
    addItem(item: string | number | boolean) {
        this.data.push(item); //Error item is ambigous 
    }

    removeItem(item: string | number | boolean) {
        this.data.slice(this.data.findIndex(item), 1); //Error item is ambigous 
    }
}

//We can Overcome this using Generics 
//In generics Type is decided only once 
class Storage <T extends string | number | boolean> {
    data: T[] = [];

//Error , we cannot add item because data can be any array
//if array is number, item can be string and other possibilites
    addItem(item: T) {
        this.data.push(item); 
    }

    removeItem(item: T) {
        this.data.slice(this.data.findIndex(item), 1); //Error 
    }
}

#endregion Generics

#region Decorators
You can apply this on class, methods , propertires 
  https://medium.com/@InspireTech/what-are-decorators-in-typescript-and-how-to-use-decorators-d82d15c5851f 

function logger(originalMethod: any, _context: any) {
  function replacementMethod(this: any, ...args: any[]) {
    console.log("start:", originalMethod.name);
    const result = originalMethod.call(this, ...args);
    console.log("end:", originalMethod.name);
    return result;
  }

  return replacementMethod;
}

class User {
  constructor(private name: string, private age: number) {}

  @logger
  greet() {
    console.log(`Hello, my name is ${this.name}.`);
  }
}

#endregion Decorators