Why should hooks not be in loops after conditions , inside functions etc?
 https://reactjs.org/docs/hooks-rules.html

NOTE : STOP THINKING ABOUT LIFE CYCLE METHODS WHILE USING HOOKS , THINK IN TERMS OF STATE CHANGES

React Hooks Video: https://www.youtube.com/watch?v=1jWS7cCuUXw&t=3326s

#region HOOKS , MOTIVATION INTRO
Even before hooks we need to know what are functional components.
Functional components are not new to react, they existed right from the begining, but are used as dumb/presentational components only i.e these components don't involve in state change. Where as class components , were used for state changes and lifecycle methods hence they are called as "container" components.

Class components Vs Functional Components: Before 16.8 , before hooks

But with ES6, functional components have got new look , courtesy arrow functions, and better capabilites with hooks, which are on par with class components .
Functional components have only props passed by its parent. Class can have props and state
FC cannot have life cycle methods. CC can have life cycle methods.
FC are used for presentational component. CC are used for business - logic related components.
FC are easier to test. CC takes time for testing.w.r.t mocking .

TODO: Learn more differences between FC Vs CC....

Lifecycle methods can only be used in class components, where as functional components cannot make use of Lifecycle methods, to overcome that disadvantage React team has introduced HOOKS. To furnish FC with capabilites of ReactJS Classes , Hooks are been introduced from version 16.8.0 first release to support hooks.
Hooks are functional from React 16.8. React 16.8.0 is the first release to support Hooks


https://reactjs.org/docs/hooks-intro.html
What are Hooks in React?
1) Hooks let you use state and other React features without writing a class.

Why are Hooks been added to React? Disadvantages of Classes in React
https://ui.dev/why-react-hooks/ 
1) Hard to reuse stateful logic between components:(render props,HOC ar just alternates) Sharing the business logic is a challenge, D.R.Y implementation is inconvinient.
2) Class components are more verbose, Complex components beacome hard to understand.
3) Understand "this" in JS to work with Classes ."this" works  differently from other languages in js-state-without-constructor-fixing-954dbb11fcf1
4) classes don’t minify very well, and they make hot reloading flaky and unreliable

What is the hooks equivalent to??
Read first para of : https://reacttraining.com/blog/useEffect-is-not-the-new-componentDidMount/
quick answer is that hooks are a paradigm shift from thinking in terms of "lifecycles and time" to thinking in terms of "state andsynchronization with DOM"

What are Higher Order Functions?
Short Ans : A higher order function is a function that takes one or more functions as arguments.
Js functions map,reduce,filter are examples of HOF's 
https://www.freecodecamp.org/news/higher-order-functions-in-javascript-d9101f9cf528/#:~:text=Higher%20order%20functions%20can%20help,short%2C%20simple%2C%20and%20readable.&text=map%20%2C%20you%20provide%20a%20function,element%20contained%20in%20the%20array.

Follow examples in Project : W:\INTERVIEWS_2020\PRACTICE_DEMOS_NOTES\REACT\Session-1\firstapp\src\HOOKS

Render Props/ HOC's/Lift the Props  are patterns 
Render Props: https://blog.bitsrc.io/understanding-render-props-in-react-1edde5921314

What are HOC's?
https://www.smashingmagazine.com/2020/06/higher-order-components-react/

Problems with HOC's well explained ?
https://www.kirillvasiltsov.com/writing/thinking-in-react-hooks/




#endregion HOOKS
#region Basic Hooks useState(), useEffect(),useContext()

React hooks cheatsheet : https://react-hooks-cheatsheet.com/

array destructuring : 
const [a,b,...c] = [1,2,3,4,5,6] ;  a =1 b=2 c=[3,4,5,6]

https://www.valentinog.com/blog/hooks/
https://www.smashingmagazine.com/2020/04/react-hooks-api-guide/

What is a closure ?
https://medium.com/@kevinwkds/javascript-closure-pitfalls-f9f44349d92d

Some frameworks are reactive, meaning they automatically detect changes and update the UI when changes occur.
React does not do this – it will only re-render in response to state changes

When would I use a Hook? If you write a function component and realize you need to add some state to it, previously you had to convert it to a class. Now you can use a Hook inside the existing function component. We’re going to do that right now!


#region useState()
https://reactjs.org/docs/hooks-state.html
1) useState() runs on every render. and updates the current state
2) variables “disappear” when the function exits but state variables are preserved by React.In the below example
React will remember its current value between re-renders, and provide the most recent one to our function. If we want to update the current count, we can call setCount.
3) useState, creates the state only on the first render subsequent renders react gives us current state.Hence "useState" is apt name.
4) We can make use of multiple useStates in functional components.
//Inside functional component
const [age, setAge] = useState(42);
const [fruit, setFruit] = useState('banana');
const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);
But also we can make use of traditional object/array for useState. But there are sutle disadvantages .
https://reactjs.org/docs/hooks-faq.html#should-i-use-one-or-many-state-variables.
a) we can move the code easily to some custom-hook.  
  
Basic example and useState vs this.state
function Example() {
  // Declare a new state variable, which we'll call "count"
  const [count, setCount] = useState(0);
  return (
    <div><p>You clicked {count} times</p><button onClick={() => setCount(count + 1)}>Click me</button></div>
  );
}

same as class example:
class Example extends React.Component {
  constructor(props) {    super(props);    this.state = {      count: 0    };  }
  render() {
    return (      <div>        <p>You clicked {this.state.count} times</p>        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Click me
        </button>
      </div>
    );
  }
}

useState vs this.state:
1) useState, replace the state and rewrites the state, each time new/current state is given to the current component,WHERE AS in this.state , the state is merged from setState() , its not overwritten.Hence useState((prev) =>({...prev,oldVal:currentVal})) is best approach
const[obj,setObj] = useState({a:2,b:3})
setObj({a:4})
console.log({obj}) //{a:4}, the value of b is lost 
Where as in class component 
setState({a:this.state.a+2})
console.log(this.state) //{a:4,b:3} the state is merged not overwritten.

2) in function components we don't use this at all. Hence we can get rid of this phobia. WHere as classes heavily depend on this.

can we use function/cb inside useState() ?
Yes we can use eg
const Message= () => {
   const messageState = useState( () => expensiveComputation() );
   /* ... */
}
use a function to lazily initialize the state variable (useful when the initial state is the result of an expensive computation):
The initial value will be assigned only on the initial render (if it’s a function, it will be executed only on the initial render).
In subsequent renders (due to a change of state in the component or a parent component), the argument of the useState Hook will be ignored and the current value will be retrieved.

How to sync state updates ?
https://stackoverflow.com/questions/54625831/how-to-sync-props-to-state-using-react-hooks-setstate
useState hooks function argument is being used only once and not everytime the prop changes. 
You must make use of useEffect hooks to implement what you would call the.

But why does useState() return an array why not an object ?
with array there is a chance of choosing the meaningful names directly
consider const {a:A,b:A} = useState() //here object destructured we will have to go with prop name or give aliases 

NOTE: state is not updated the value right away.because of bulk updates of virtual dom.
React enqueues the update operation. Then, after re-rendering the component, the argument of useState will be ignored and this function will return the most recent value.
the previous value to update state, you must pass a function that receives the previous value and returns the new value
setMessage(prev => prev + val)

NOTE :if you use the same value as the current state to update the state (React uses Object.is for comparing), React won’t trigger a re-render.
NOTE: React uses Object.is to compare the Objects ,
Primer on Object.is Vs ===
Object.is(NaN,NaN) true
NaN === NaN false
NaN == NaN false
Object.is(+0,-0) false
+0 === -0 true
Object.is({a:2,b:{c:3}},{a:2,b:{c:3}}) //False
Object.is({a:2,b:3},{a:2,b:3}) //false

https://blog.logrocket.com/a-guide-to-usestate-in-react-ecb9952e406c/#:~:text=useState%20is%20a%20Hook%20(function,function%20to%20update%20this%20value.

useState under the Hood:
https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/
We use closures internall, which can remember lexical scope of the parent , when executed outside the scope.

Making sense of react hooks:
https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889

Hooks are not Magic , Visual Explaination:
https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e

#endregion



#region useEffect

useEffect can act as 
	a) componentDidMount()
	b) componentDidUpdate()
	c) componentWillUnmount()

In brief all the side-effects related code and cleaning up code done during unmount can be done in useEffect()
	
Functions passed to useEffect are executed on every component rendering(i.e after every component render)—unless you pass a second argument to it.

useEffect can return only a function , i.e a clean-up function ONLY.

scenario : useEffect --> componentDidMount Behaviour 
syntax : 
useEffect(() => {
    // code to run on component mount, acts as componentDidMount()
  }, []) //empty array here is called as dependency array. When its empty there are no dependencies.
 
 NOTE: WHATEVER IS CAUSING THE SIDE-EFFECT , THAT VARIABLE SHOULD BE MENTIONED INSIDE USEEFFECT.
 NOTE: if you don't mention an empty array, that might lead to infinite loop , when you use setState inside useEffect. BECAUSE useEffect is called after every      render.
 
eg:
const UseEffectDemo = () => {
    const [age, setAge] = useState(0)
    const handleClick = () => setAge((prevAge)=> prevAge + 1)
    useEffect(() => document.body.append('You are ' + age + ' years old!\n')) //**
    return (<div><button onClick={handleClick}>Update Title!! </button>  </div>)
  }
In the above example for every button click ,your set state is triggered, which will trigger render() for every click because of setstate .
This will eventually trigger useEffect every time the render is called.

Can we limit useEffect to be called only once after render that is emulate ComponentDidMount behaviour?
Yes, we can componentDidMount runs only once in component lifecycle i.e after render(), and for every re-render componentDidUpdate() will be called.
So to achieve that with useEffect we need to pass an empty array,as second paramenter to useEffect(effectFunc,[]) hook
In the above example change the highlighted line(**) to 
useEffect(() => document.body.append('You are ' + age + ' years old!\n'),[]) //empty array passed.
Now your useEffect will run only once after the the component is mounted i.e after render().

Real-Time example with useEffect :
consider the following code snippet :
const UseEffectDemoAPICall = ()=>{
const [data,setData] = useState([])
const [error,setError] = useState(null)
useEffect(()=>{
    console.log('Use effect called') //**
    fetch('https://jsonplaceholder.typicode.com/users') //http://dummy.restapiexample.com/api/v1/employees
    .then((response)=>{
        response.json()
        .then((allEmpRes)=>{
             setData(()=>[...allEmpRes])
        })
       
    }).catch((error)=>{
        setError(()=>({...error}))
    })
}) //***
if(error){return (<div>{JSON.stringify(error)}</div>)}
return(<div>{data.length}</div>)
}

NOTE: see the highlighted(**) console-log will run infinite times , why does that happen.
for the first time , render() --> useEffect() , but useEffect has setState been called inside it ,
when ever we are calling setState() inside useEffect, setState will trigger render(), render will again trigger useEffect, again setState ,useEffect,render....
UseEffectDemoAPICall() --> render()-->setState()-->useEffect()-->setState()-->render()-->useEffect()........ infinite loop 

How to address this problem ?
see the highlighted(***) pass an empty array(which means array without dependencies) , that will limit the useEffect call to once
 
NOTE: WE CAN USE MULTIPLE useEffects in a functional component ,seperating each external call. 

How to clean up code inside useEffect ??

NOTE: the clean-up callback in useEffect is called everytime, useEffect is called .
NOt just when component unMOunts  (Praveen's session)

database connections, soctek connections will have to be closed while the component unmounts else they are security-leaks 
to achieve that in use effect :
Assume the state changes occure ,put-up a setTimeout
//Parent component :render(){return (this.state.id ===1 ? <UseEffectDemoAPICall/>:null)} 
//Inside child UseEffectDemoAPICall
useEffect(()=>{
//UseEffectDemoAPICall() --> render()-->setState()-->useEffect()-->setState()-->render()-->useEffect()........ infinite loop 
    /*
	Other API related logic
	*/
    //UseEffect has to return a function () => sayGoodBye() is also valid or function reference is valid too
return () => {console.log('Unmount the component ')}
},[])

What is the significance of the array as second parameter in useEffect??
The values in the dependency arrays are shallow compared. Even Objects are shallow compared 

What happens when useEffect dependency array has an Object ??
TODO: find out answer.

What is difference between shallow comparision and deep comparision?
https://www.mattzeunert.com/2016/01/28/javascript-deep-equal.html
In depth explaination https://dmitripavlutin.com/how-to-compare-objects-in-javascript/
  
what are gotchas of useEffect ?
https://reacttraining.com/blog/useEffect-is-not-the-new-componentDidMount/
https://kentcdodds.com/blog/react-hooks-pitfalls

UseEffect and componentDidMount or not the same , How?
componentDidMount is called just before the paint is commited, hence you cannot see the flicker 
useEffect is called after the paint has commited to the screen, hence you can see the flicker
Instead useLayoutEffect(fn,[]) is close to componentDidMount.

UseEffect is a closure, where as componentDidMount is a function.
In async/sync calls props and state values can be a bit confusion because useEffect is a closure, it will retain its initial value and increments based on that .
Example is in the blog .

Rules of hooks:
https://reactjs.org/docs/hooks-rules.html

useEffect as componentDidUpdate(prevProps,prevState,snapshot)
-------------------------------------------------------------
//Parent Component
import React, { useState } from "react"; import UseEffectCompDidUpdateChild from './UseEffectCompDidUpdateChild'
const options = [ { key: null, name: null }, { key: "1", name: "Emp1" }, { key: "2", name: "Emp2" }, ];
const UseEffectCompDidUpdate = () => { const [empValue, setEmpValue] = useState(null);
const onChangeHandler = (event) => { setEmpValue(event.target.value); };
const findName = (optKey) => { return options.find(({ key }) => key === optKey)?.name; };
 return ( <div> <div> <label>Select an Employee</label>{" "} </div> <select onChange={onChangeHandler}> {options.map(({ key, name }) => { return ( <option key={key} value={key}> {name} </option> ); })} </select> {empValue && ( <div> Selected Value : {findName(empValue)} <UseEffectCompDidUpdateChild empValue={empValue}/> <div> </div> </div> )} </div> ); };
export default UseEffectCompDidUpdate; 


//ChildComponent
import React, { useState, useEffect } from "react";

const UseEffectCompDidUpdateChild = ({ empValue }) => { const [projects, setProjects] = useState([]); const fetchProjects = (id) => { if (!id) return null; setTimeout(() => { const projs = id === "1" ? ["Alpha", "Beta"] : ["Charlie", "Delta"]; setProjects(projs); }, 300); };
 useEffect(() => fetchProjects(empValue), [empValue]); //empValue is given inside dependency array 
 if (!empValue) { return null; } return ( <div> UseEffectChildComponent {projects.map((project) => { return <div>{project}</div>; })} </div> ); }; export default UseEffectCompDidUpdateChild; 
#endregion useEffect

#region RENDER PROPS , Pattern in react
Render props is for efficiently re-using code.
A component with a render prop takes a function that returns a React element and calls it instead of implementing its own render logic
consider following example : 
<B renderFn={(a,b,c)=></C>}
//Class B implementation
class B {
render(){
return (this.props.renderFn(a,b,c))
}
}

Render props , simply is transclusion, in AngularJs
You already have the data ready, in component But you can decide the template in which the data can be rendered 
For eg: Reusability example
EmpComponent have list of employees , employees is passed to the 
export class EmpComponent extends React.Component { state = { employees: [...employees], };
 render() { const { employees } = this.state; return ( <div> 
 {this.props.render({ employees: employees, })}  //FOCUS HERE 
 
 </div> ); } }
 
EmployeeButtons component will give you the template in the render prop
//In Below example render is sending the template, in which emp data to be displayed
export class EmployeeButtons extends React.Component { render() { return ( <> <h1>Render Props Demo</h1> <EmpComponent render={({ employees }) => { return employees.map(({ name, experience }) => { return ( <div style={{ padding: "10px" }}> <button name={name} key={experience}> {name.toUpperCase()} </button> </div> ); }); }} /> </> ); } }

EmployeeList component will give you the template in the render prop
//In Below example render is sending the template, in which emp data to be displayed
export class EmployeeList extends React.Component { render() { return ( <> <h1>Render Props Demo List</h1> <EmpComponent render={({ employees }) => { return employees.map(({name,experience})=>{ return (<li key={experience}>{name}</li>) })}}/> </> ); } }


NOTE : Different ways of Implementing Render Props 
https://blog.logrocket.com/react-reference-guide-render-props/
Another advantage of render props is that the prop doesn’t have to be called render. You could call it whatever you want as long as the prop is invoked in the render method. This leads to interesting implementations,

export class RenderPropsImplStyle extends React.Component { state = { employees: [...employees], }; render() { return <div>{this.props.children(this.state.employees)}</div>; } } //Implemented using children , pass emploee as parameter

export class BaseComponent extends React.Component { render() { return ( <RenderPropsImplStyle>
 { //USAGE AS CHILDREN IN BASE COMPONENT
(employees) => { return ( <div> <h1>Render Props Implementation using "this.props.children([params])"</h1> <div>{JSON.stringify(employees)}</div> </div> ); }} </RenderPropsImplStyle> );
} }

Disadvantages ,of Render Props while using Render.PureComponent, explained here https://blog.logrocket.com/react-reference-guide-render-props/
to avoid shallow comparison , rather than passing anonymous function to render props pass , named function .

#endregion RENDER PROPS , Pattern in react

#region Context in classes and useContext() Hook

READ ON RENDER PROPS BEFORE CONTEXT 

https://reactjs.org/docs/context.html

What is context in React ?
1) Context provides a way to pass data through the component tree without having to pass props down manually at every level.
2) In typical react application, consider user preferences, UI Themes etc are required by every component, passing these pieces of info following parent-child paradigm is tedious,cumbersome task, Context allows us to share the common data among components without using parent-child-info-passage paradigm.

NOTE : You can give your component a context type: MyComponent.contextType = ColorContext; then, you can access the context in your component: let context = this.context; and that allows you to access your context outside of the JSX. Or instead, you could put in static contextType = ColorContext;

WHat problem does CONTEXT solve for us ?
consider the following composition of the components 
<A name={'Ajay'}>  //How to Pass name prop to <D> ??
	<B> //name thru B
		<C> //name thru C
			<D> // name comes to D
			{name}
			</D>
		</C>
	</B>
</A>

In above example B and C doesn't need "name", but still have to weigh the prop so that it can be passed to D , this is called as "prop-drilling"

To avoid such a problem we will use CONTEXT in React

Always nearest provider/context will be picked up. 

Links:
https://www.robinwieruch.de/react-context
https://www.digitalocean.com/community/tutorials/react-usecontext

Steps for creating Context:
---------------------------
STEP 1: 
-> Create the context itself which will give you a provider and consumer.
-> When you create the context with React by using createContext, you can pass it an initial value. The initial value can be null too.

// src/ThemeContext.js
import React from 'react';
const ThemeContext = React.createContext(null);
export default ThemeContext;

STEP 2:
A would have to provide the context with the given Provider component.
The value can be anything, fetched from API,modified React state,anything

//src/ComponentD
import C from './ComponentC'
class D {
render() {<C/>}
}

// src/ComponentA.js
 import React from 'react';
import ThemeContext from './ThemeContext'; //MANDATORY
const A = () => (
  <ThemeContext.Provider value="green">
    <D />
  </ThemeContext.Provider>
);
Here in the above example the value green is passed to component D without passing any props . However compD has compC as child , even childC can access the context value , see STEP 3

STEP 3:
//src/ComponentC.js
import React from 'react'
import ThemeContext from './ThemeContex'
const C = () =>{
<ThemeContext.Consumer>
{value  
<p style={{clor:value}}> Hello World </p>
)
</<ThemeContext.Consumer>
}

Scenarios: When to use context:
1) When your React component hierarchy grows vertically in size and you want to be able to pass props to child components without bothering components in between. We have used this use case as example throughout this whole React Context tutorial.
2) When you want to have advanced state management in React with React Hooks for passing state and state updater functions via React Context through your React application. Doing it via React Context allows you to create a shared and global state.

consider the below component
<TodoComponent/> //All state and actions defined here
	<TodoList/>
		<TodoItem/> //actions get executed and displayed here, but these have to passed thru TodoList/
This is Prop-Drilling

Eg:Check VsCode example



Example :
https://itnext.io/understanding-the-react-context-api-through-building-a-shared-snackbar-for-in-app-notifications-6c199446b80c
https://medium.com/@jeromefranco/how-to-avoid-prop-drilling-in-react-7e3a9f3c8674

#endregion useContext()






#region React.Memo, useMemo and useCallback hook
https://www.robinwieruch.de/react-usecallback-hook
https://www.robinwieruch.de/react-memo
https://www.robinwieruch.de/react-usememo-hook


BIG NOTE: 
Keep in mind that most of the performance optimizations in React are premature. React is fast by default, so every performance optimization is opt-in in case something starts to feel slow.

REACT RE-RENDERINGS ARE FAST, OPTIMIZATIONS ARE OPT-IN, SONTHA DOOLA.



Note: Don't mistake React's useCallback Hook with React's useMemo Hook. While useCallback is used to memoize FUNCTIONS, useMemo is used to memoize VALUES.

#region React.Memo
------------------
React's memo API can be used to optimize the rendering behavior of your React function components.

Eg:
import React, { useState } from "react";

/* Consider below example Everytime your text changes all the three components ReactMemoProblem,List,ListItem renders because there is a change in state of the ReactMemoProblem component, List and ListItem are its child components Which also gets re-rendered, even though there isn't necessity . The item is added only when we click on "addUser" button So if you see the console, you can see the logs multiple times The above might not be a problem in this case once your users grow then i might cause slow performance due to multiple re-renderings
 To solve the above said problem we use React.memo Now only ReactMemoSolution re-rendered because of state, on addUser btn click, ListItem, List are rendered React.memo is followed bt ListItem too because, List is applied with memo
However if you see , onclick of addUser btm ListItem is rendered thrice, 2 times for existing users 1 time for new user, 
We can memoize the LIstItem only to render for newly added user using React.memo
*/

const ReactMemoSolution = () => { console.log("Render Solution: App"); const [users, setUsers] = useState([ { id: 1, name: "Ajay" }, { id: 2, name: "Kumar" }, ]);

 const [text, setText] = useState("");

 const handleChange = (e) => setText(e.target.value); const handleAddUser = () => setUsers(users.concat({ id: users[users.length - 1].id + 1, name: text })); return ( <div> <input type="text" onChange={handleChange} /> <button onClick={handleAddUser}>Add User </button> <List list={users} /> </div> ); };

const List = React.memo (({ list }) => { console.log("Render Solution: List"); return ( <ul> {list.map((item) => ( <ListItem key={item.id} item={item} /> ))} </ul> ); });

const ListItem = React.memo(({ item }) => { console.log("Render Solution: ListItem"); return <li>{item.name}</li>; });

export default ReactMemoSolution

You might be wondering why you wouldn't use React memo on all your components or why React memo isn't the default for all React components in the first place.

Internally React's memo function has to compare the previous props with the new props to decide whether it should re-render the component. Often the computation for this comparison can be more expensive than just re-rendering the component.

#endregion React.Memo


#region useMemo

useMemo:
-------

syntax : useMemo(fn,[/*depnedency Array*/])

React's useMemo Hook can be used to optimize the computation costs of your React function components

useMemo Vs React.Memo
---------------------
Don't mistake React's memo API with React's useMemo Hook. While React memo is used to wrap React components to prevent re-renderings, useMemo is used to memoize values, precisely return values of the functions.

useMemo vs useCallback
-----------------------
Note: Don't mistake React's useMemo Hook with React's useCallback Hook. While useMemo is used to memoize values, useCallback is used to memoize functions.

EG:
import React, { useMemo } from "react";

/* Consider the below example , filteredUsers run for every inputchange Even though the filteredUsers don't change when someone types into the input field, because they change only when clicking the button via the search state
For a small demo like this might not make a big difference but what happens when there are 1000 names to lookup? You application might slow down
you can use React's useMemo Hook to memoize a functions return value(s) and to run a function only if its dependencies (here search) have changed */

const users = [ { id: 1, name: "Alpha" }, { id: 2, name: "Beta" } ];

const UseMemoSolution = () => { const [text, setText] = React.useState(""); const [search, setSearch] = React.useState("");

 const handleText = (e) => setText(e.target.value); const handleSearch = () => setSearch(text); const filteredUsers = useMemo(() =>{ return(users.filter((user) => { console.log('useMemo Solution filtered users running...') return user.name.toLowerCase().includes(search.toLowerCase()); }))},[search]);

 return ( <div> <input type="text" value={text} onChange={handleText} /> <button type="button" onClick={handleSearch}> Search </button> <List list={filteredUsers} /> </div> ); };

const List = ({ list }) => { return ( <ul> {list.map((item) => ( <ListItem key={item.id} item={item} /> ))} </ul> ); };

const ListItem = ({ item }) => { return <li>{item.name}</li>; };

export default UseMemoSolution; 


After all, you may be wondering why you wouldn't use React's useMemo Hook on all your value computations or why React's useMemo Hook isn't the default for all value computations in the first place. Internally React's useMemo Hook has to compare the dependencies from the dependency array for every re-render to decide whether it should re-compute the value. Often the computation for this comparison can be more expensive than just re-computing the value. In conclusion, React's useMemo Hook is used to memoize values.

#endregion useMemo

#region useCallback

Note: Don't mistake React's useCallback Hook with React's useMemo Hook. While useCallback is used to memoize functions, useMemo is used to memoize values.

Note: Don't mistake React's useCallback Hook with React's memo API. While useCallback is used to memoize functions, React memo is used to wrap React components to prevent re-renderings.

import React, { useCallback, useState } from "react";

/* UseCallBackSolution ,List and ListItem(2 renders. users.length) will be re-rendered on every textChange , however List and ListItem should render only on AddName button is clicked , to prevent we use React.memo,

 Even on adding React.memo UseCallBackSolution ,List and ListItem will be re-rendered on every textChange WHY? Because removeUserHandler is redefined for every re-render and passed on to subsequent child elements As there is change in props, the re-render continues. 

 To resolve this issue we use useCallBack with a dependency array, in this case the dependency is users Only when user is added or removed the rendering of List and ListItem happens . Thus re-renders on text change are prevented */

const UseCallBackSolution = () => { console.log(" UseCallBackSolution Rendered"); const [users, setUsers] = useState([ { id: "1", name: "Alpha" }, { id: "2", name: "Beta" }, ]); const [text, setText] = useState(""); const handleChange = (e) => setText(e.target.value); const handleAddUser = () => { setUsers((prevArr) => [ ...prevArr, { id: prevArr[prevArr.length - 1].id + 1, name: text }, ]); }; const removeUserHandler = useCallback((userId) => setUsers(users.filter(({ id }) => id !== userId)),[users])

 return ( <div> <input type="text" onChange={handleChange} value={text} /> <button onClick={handleAddUser}>Add User </button> <List list={users} onRemoveHandler={removeUserHandler} /> </div> ); };

const List = React.memo(({ list, onRemoveHandler }) => { console.log("List Rendered"); return ( <ul> {list.map((item) => ( <ListItem key={item.id} item={item} onRemoveHandler={onRemoveHandler} /> ))} </ul> ); });

const ListItem = React.memo(({ item, onRemoveHandler }) => { console.log("ListItem Rendered"); return ( <li> <div> <span>{item.name}</span>{" "} <button onClick={() => onRemoveHandler(item.id)}>Remove User</button> </div> </li> ); });

export default UseCallBackSolution; 

You might be wondering why you wouldn't use React's useCallback Hook on all your functions or why React's useCallback Hook isn't the default for all functions in the first place.

Internally, React's useCallback Hook has to compare the dependencies from the dependency array for every re-render to decide whether it should re-define the function. Often the computation for this comparison can be more expensive than just re-defining the function.

#endregion useCallback














Important Notes on useMemo,useCallBack,React.memo
---------------------------------------------------
https://dmitripavlutin.com/dont-overuse-react-usecallback/
https://dmitripavlutin.com/use-react-memo-wisely/

In JS, An object (including a function object) equals only to itself.


#endregion useMemo and useCallback hook


#region createRef and useRef
createRef vs useRef : https://dev.to/dinhhuyams/introduction-to-useref-hook-3m7n
other references : https://www.codebeast.dev/react-memoize-hooks-useRef-useCallback-useMemo/

createRef creates mutable a new reference for every re-render
useRef creates mutable reference only once and thats lasts full life time of the component
Both are mutuable, and causes NO re-renders
eg:
import React from "react";
class CreateRefComponent extends React.Component { inputEl = React.createRef()
 handleClickHandler = () => { this.inputEl.current.onmouseover = () => (this.inputEl.current.value = "You are Hovering"); this.inputEl.current.onmouseout = () => (this.inputEl.current.value = ""); };
 render() { return ( <> <button onClick={() => this.handleClickHandler()}> Click Here for TextBox </button> <input type="text" ref={this.inputEl} /> </> ); } }
export default CreateRefComponent 

CreateRef Vs UseRef Example
---------------------------
import React, { useRef, createRef, useState } from "react";
const CreateRefVsUseRef = () => { const createRefInp = createRef(); const useRefInp = useRef(null); const [count, setCount] = useState(0); if (!useRefInp.current) { useRefInp.current = count; } if (!createRefInp.current) { createRefInp.current = count; } return ( <> <p>Current render index: {count}</p> <p> <b>refFromUseRef</b> value: {useRefInp.current} </p> <p> <b>refFromCreateRef</b> value:{createRefInp.current} </p> <button onClick={() => setCount((prevCount) => prevCount + 1)}> Click to Rerender </button> </> ); };
export default CreateRefVsUseRef

In the above example for every setCount, your createRef reference is created, where as useRef reference is created only once.

UseRef in detail:
syntax : const refContainer = useRef(initialValue);
useRef returns a mutable ref object (in this case refContainer)whose ".current" property is initialized to the passed argument (initialValue). The returned object will persist for the full lifetime of the component.

Eg:
import React, { useRef } from "react";
const SimpleUseRefDemo = () => { const inputEl = useRef(null); const handleClickHandler = () => {  inputEl.current.onmouseover=()=>inputEl.current.value = 'You are Hovering' inputEl.current.onmouseout=()=>inputEl.current.value = '' }; return ( <> <button onClick={handleClickHandler}>Click Here</button> <input type="text" ref={inputEl} /> </> ); };
export default SimpleUseRefDemo; 

Essentially, useRef is like a “box” that can hold a mutable value in its .current property.
useRef() creates a plain JavaScript object. The only difference between useRef() and creating a {current: ...} object yourself is that useRef will give you the same ref object on every render.
However, useRef() is useful for more than the ref attribute. It’s handy for keeping any mutable value around similar to how you’d use instance fields in classes.

USE-CASES w.r.t useRef
----------------------
1) DOM manipulation is straight use-case, Example shown above
2) If you want to add state to your component that persists across renders and can trigger a re-render when it’s updated, go with useState or useReducer. If you want to add state to your component that persists across renders but doesn’t trigger a re-render when it’s updated, go with useRef.Example below https://ui.dev/useref/

useState vs useRef:
1)useState causes re-render; useRef does not.
2) Both useState and useRef remembers their data after a re-render
3) useRef is mutable, useState is immutable

useRef is similar to useState, but without setState function, that causes re-renders.
https://www.codementor.io/@dhananjaykumar/useref-hook-as-mutable-ref-object-ykb77fwvk

import React, { useState } from "react";

const UseRefVsUseState = () => { //The count below is re-initialized for evvery re-render, cannot hold the previous value //persistence during re-renders is not possible let count = 0; const [state, setState] = useState("A"); const handleClick = () => { setState((prevState) => prevState + "--u--"); count++; }; return ( <> <div>State:{state}</div> <div>Show count: {count}</div> <button onClick={handleClick}>Click Me!!</button> </> ); }; 

const UseRefVsUseStateSolution = () => { const countRef = useRef(0); const [state, setState] = useState("A"); const handleClick = () => { setState((prevState) => prevState + "--u--"); countRef.current++; }; return ( <> <div>State:{state}</div> <div>Show count: {countRef.current}</div> <button onClick={handleClick}>Click Me!!</button> </> ); };

What is React.ForwardRef??
Find ans

Can you pass key from parent to child, can you pass ref to child ?
UseImperativeHandle from child to parent access functions of child in parent 

#endregion useRef


#region useReducer 
useReducer detail explaination 

NOTE:  For examples see the VSCode first-app project
syntax : 
const [state, dispatch] = useReducer(reducer, initialArg, init);

references:
https://alligator.io/react/usereducer/

useReducer + useContext
https://hswolff.com/blog/how-to-usecontext-with-usereducer/

Basics of redux, definitions for action/reducer/dispatch etc
https://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers


#region What is the reducer?
----------------------------
Reducers are functions that take the current state and an action as arguments, and return a new state result. In other words, (state, action) => newState
Draw an analogy w.r.t coffee maker , reducers are functions that take in the current state (coffee powder) and actions (water) and brew a new state (fresh coffee).

Rules of Reducers : REDUCERS SHOULD BE PURE FUNCTIONS like render(), ctor
1) They should only calculate the new state value based on the state and action arguments
2) They are not allowed to modify the existing state. Instead, they must make immutable updates, by copying the existing state and making changes to the copied values.
3) They must not do any asynchronous logic or other "side effects"

What is an action?
-----------------
In general sense action you can think of an action as an     event( ex: CRUD) that describes something that happened in the application with your state. Action are javascript objects with {type:'blabla',payload:'blabla'} properties

What is initialState ?
----------------------
Seed data for your application to launch and start working with

What is dispatch?
-----------------
dispatch is an alias for action i.e inside reducer function.

What is useReducer hook?
------------------------
useReducer is another state managing hook, like useState, but useReducer is used for more complex state managing scenario's.
The useReducer hook uses the same concept as the reducers in Redux. It is basically a pure function, with no side-effects.
Pure functions:
1) gives same output, when you give same set of inputs
2) no API's and mutations inside reducers , these causes side effects.

#endregion What is the reducer

#region useReducer Vs useState 
----------------------
Reference : https://www.robinwieruch.de/react-usereducer-vs-usestate
As a rule of thumb, when ever you are dealing with 
State which holds JS primitives(boolean,integer,string,number) we can make use of 'useState' hook.
state that deals with complex arrays, objects , we can make use of useReducer.

for eg: The rule of thumb suggests that, for instance, once you spot const [state, setState] = useState({ firstname: 'Robin', lastname: 'Wieruch' }) in your code, you may be better off with useReducer instead of useState.

Good Practices :
Consider the following example this is very implicity coded, which is wrong practise
const counterReducer = (state, action) => {
  switch (action.type) {
    case 'INCREASE_OR_DECREASE_BY':
      return state + action.by;
    default:
      throw new Error();
  }
};
//USAGE
//dispatch({ type: 'INCREASE_OR_DECREASE_BY', by: 1})
//dispatch({ type: 'INCREASE_OR_DECREASE_BY', by: -1 })

CORRECT Practise : In this case business logic is seperate , readable concise
const counterReducer = (state, action) => {
  switch (action.type) {
    case 'INCREASE':
      return state + 1;
    case 'DECREASE':
      return state - 1;
    default:
      throw new Error();
  }
};
//dispatch({ type: 'INCREASE', by: 1})
//dispatch({ type: 'DECREASE', by: 1 })
#end region useReducer Vs useState


#endregion useReducer

#endregion


Scenario: useLayoutHook
------------------------
I want to change the css of anchor tag from blue to black and on hover i need to show underline.
If I use useEffect , when the screen is loading initially the <a> are blue then the css is getting applied where the links are turning black 
Thats easily visible and bad user experience

jsx is below
<ul id="ulList">
<li> <a> </li>
</ul>

useLayoutEffect(() => {
	const uls = document.selector("#ulList")
	uls.classList.add("customAnchrCss");
},[])