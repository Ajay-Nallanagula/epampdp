Udemy : https://www.udemy.com/course/nextjs-react-the-complete-guide/learn/lecture/41160686#overview

#region Getting Started

NextJs Vs React: https://radixweb.com/blog/nextjs-vs-react#difference

What is Next.Js? Its open source
https://radixweb.com/blog/nextjs-vs-react#difference
1) Next JS is a JavaScript framework that allows developers to create user-friendly and blazing fast static websites and static web applications with React. Next JS is an open-source, lightweight web development framework for React applications. It allows developers to build server-side rendering.

2) Next.js is based on React babel and webpack, which provides an out-of-the-box solution for server-side rendering (SSR) of React components

3) Next.js provides many features, such as static export, preview mode, pre-rendering, faster compilation, and automatic building size optimization.

What is Next.js Used for?
1) ECommerce Websites
2) Marketing Websites
3) Landing Pages

Why do you need Next.Js when React is already there?

Next. Js Provides oUt-of-box support for 
Server-side Rendering (SSR)
Static Export (SSG)
Pre-rendering
Automatic Build Size Optimization
Enhanced Development Compilation
Route Setup and Handling
Form Submission
Data Fetching
Authentication.

Next.js provides many features, such as static export, preview mode, pre-rendering, faster compilation, and automatic building size optimization, automatic Code-splitting

What is Code-Splitting?
https://web.dev/learn/performance/code-split-javascript#:~:text=Code%20splitting%20is%20a%20useful,loaded%20at%20any%20other%20time.

Example:
document.querySelectorAll('#myForm input').addEventListener('blur', async () => {
  // Get the form validation named export from the module through destructuring:
  const { validateForm } = await import('/validate-form.mjs');

  // Validate the form:
  validateForm();
}, { once: true });

When Should we use Next.js?

PageRouter Vs AppRouter
========================

#endregion 

#region NextJs Interview Questions

#region Links
https://hackernoon.com/30-nextjs-interview-questions-get-ready-for-your-dream-job
https://mindmajix.com/next-js-interview-questions

<a href> Vs <Link href=/>
=========================
With anchor tag, there is a new http request sent to theserever to fetch the page , which means stateless, all the state in redux/context will be lost 
With <Link>  this is client side routing happens , HTTP request is not sent to the server. app state is not lost.
Automaticall pre-fetches the data , pages that we might need are eagerly downloaded.

There are two ways of configuring a route in the <Link>
const client = [
        { id: 'ajay', name: 'AjayNallanagula' },
        { id: 'Divya', name: 'DivyaNallanagula' }
    ]
 client.map(route => <li key={route.id}>
 //WAY 1: 
                <Link href={`/client/${route.id}`}>{route.name}</Link> 
				
			//WAY 2
                <Link href={{
                    pathname: '/client/[id]',
                    query: { id: route.id }
                }}>{route.name}</Link>
            </li>



Incase If you need to navigate progamatically :
const router = useRouter()
    console.log('ClientId', { router })
    const handleNavigate = () => {
        router.push('/client/max/routeOnClick')
    }

#endregion Links

#region Questions
NextJs can be used to build :
Several types of websites and applications can be built. But the most popular are-
Desktop websites
Static websites
Server rendered applications
SEO friendly websites
Progressive web applications (PWA)

What is meant by Styled JSX in Next JS?
We use this CSS-in-JS library for writing encapsulated and scoped CSS for styling Next JS components. No other component gets affected by introducing the styles to a component using Styled JSX. This allows adding, changing, and deleting the styles without any complications.

Is Next JS backend, frontend, or full-stack?
Next JS is full-stack. This means that it allows rendering client-side as well as server-side content. And this is the reason it is highly valued on React, as React allows only frontend development without it.

Next JS provides two types of pre-rendering- Server-side rendering and Static rendering.
Static Generation- It generates the HTML at build time, and we can reuse it on each request. It is the recommended one of the two. For using Static generation, either the page component has to be exported or 'getStaticProps'

Server-side rendering- It generates the HTML on each request. For using Server-side rendering, 'getServerSideProps' has to be exported.

NOTE: By default, Static Generation is the pre-render available in Next JS without any data fetched

What are the most important features introduced in Next.js 12.1?
The most important features are given below-
New Rust-based compiler
Faster image optimization
On-demand incremental static regeneration (Beta)
Self-hosted Next JS improvements
Zero-configuration Jest plugin
React 18 support

Which key features are provided by Next JS in terms of SEO?
The following perks are there-

Jamstack compatibility
Increased flexibility in designing the UX of our website
Automatic static optimization
Improved data security
Fast static websites
Responsiveness and adaptability

List some competitors and alternatives to Next JS.
Some alternatives to Next JS are listed below-

Gatsby
React
Create React App
Hexo
Hugo
LoopBack
Angular Universal
React Router

#endregion Questions

#endregion NextJs Interview Questions

#region NextJs Concepts 

#region Reserverd Names in Next.js
Here's a list of reserved filenames in NextJS - you'll, of course, learn about the important ones throughout this section:

page.js => Create a new page (e.g., app/about/page.js creates a <your-domain>/about page)

layout.js => Create a new layout that wraps sibling and nested pages

not-found.js => Fallback page for "Not Found" errors (thrown by sibling or nested pages or layouts)

error.js => Fallback page for other errors (thrown by sibling pages or nested pages or layouts)

loading.js => Fallback page which is shown whilst sibling or nested pages (or layouts) are fetching data

route.js => Allows you to create an API route (i.e., a page which does NOT return JSX code but instead data, e.g., in the JSON format)

#endregion Reserverd Names in Next.js

#region <Link> in Next.Js

import Link from "next/Link"

https://nextjs.org/docs/pages/api-reference/components/link
<Link> is a React component that extends the HTML <a> element to provide prefetching and client-side navigation between routes. It is the primary way to navigate between routes in Next.js.

What is Prefetch? 
https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching
Prefetching is a way to preload a route in the background before the user visits it.

What is Dynamic Routing?
https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes
When you don't know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time or prerendered at build time

What is Prerendering?
https://nextjs.org/docs/pages/building-your-application/rendering
By default, Next.js pre-renders every page. This means that Next.js generates HTML for each page in advance, instead of having it all done by client-side JavaScript. Pre-rendering can result in better performance and SEO. Each generated HTML is associated with minimal JavaScript code necessary for that page.

#endregion <Link>

#region <Image> in Next.js

Html <img> Vs NextJs <Image> ?
https://nextjs.org/docs/app/api-reference/components/image
https://nextjs.org/docs/app/building-your-application/optimizing/images

html : <img src={logo.src} alt="Food served on Plate" />
NextJs: <Image src={logo} alt="Food served on Plate" />

The Next.js Image component extends the HTML <img> element with features for automatic image optimization:

Size Optimization: Automatically serve correctly sized images for each device, using modern image formats like WebP and AVIF.
Visual Stability: Prevent layout shift automatically when images are loading.
Faster Page Loads: Images are only loaded when they enter the viewport using native browser lazy loading, with optional blur-up placeholders.
Asset Flexibility: On-demand image resizing, even for images stored on remote servers

"Priority" prop on <Image>:  this prop is added to tell the Image component to not load using lazy loading, thus avoiding the flickering effect

#endregion <Image>

#region Css and Styling in Next.Js
What are various CSS Styles followed in Next.Js?
https://nextjs.org/docs/app/building-your-application/styling

What is Css-in-Js?
https://blog.logrocket.com/css-vs-css-in-js/

#endregion Css and Styling in Next.Js

#region ****Server Vs Client Components


Scenario: assume we have a React component(SlideShow) that needs to be displayed on the Next.Js Page route 
When you careate the compnent and try to render the component we see an error saying 
ERROR MESSAGE: You're importing a component that needs useEffect. It only works in a Client Component but none of its parents are marked with "use client", so they're Server Components by default.
Learn more: https://nextjs.org/docs/getting-started/react-essentials

Answer: That difference is there in React itself Vanilla React appas is a client library, that render components on the client. Where as Next.Js is a full stack app(Server side + Client-Side) Which means code executes in the Backend
--> Backend executes the server component functions and hence derives the to-be-rendered HTML
--> The client side recieves and renders the to-be-rendered HTML
Hence in the nextJs apps on backend side the react isn't understandable , its not recognized

This is the advantage of Next-Js because of Less client-side JS, great for SEO.
Websearch crawlers will now see the complete finished content , chances are that your website will be ranked high.


#region "use server" directive
But How do we render the client-side-react components in NextJs ?
Answer: We need to use 'use client' directive on the react components that needs to be rendered on the client side, Next Js pre-renders the pages, but react component can be opted in using "use client"
In Backend of NextJs, the code doesn't understand what is useState, useReact and other hooks
In Backend of NextJs, the code doesn't understand what the evenets like onClick, onHover and other events they are browser events 
To 

** Always separate the client components, even though they are small parts.
**Maximise the use of server rendering supported by NextJs.

How do you execute a specific functionality on server side ?
"use server" : This will enable a specific functionality or funtion to be executed on Server

//The below function is guranteed to execute on the server
//To really turn this action into server action we need to add "async" //keyword
//If async is missed Error: Server actions must be async functions
async function shareMeal(){
	"use server"
	.......
}

consider a <form onSubmit={handleSubmit}> element in general this 
is the way we design forms on client side where on handleSubmit will send the formData to backend, but when we are rendering this from backend itself , How do we achieve it 
--> We achieve it using <form action={evaluateFormData}/> in this case the "use server" will be used .
//The below function is guranteed to execute on the server
//To really turn this action into server action we need to add "async" //keyword
//If async is missed Error: Server actions must be async functions
async function evaluateFormData(formData){
	"use server"
	.......
}
--> action method in HTML5 is used to give the "post endpoint", in NextJs its been customised to give the server function, this is available out of the box.

What will happen If my component is rendered on client("use client"), and I want to do "use server"
Example:
"use client"
//Client Component
Client_Comp{

//NOTE: THIS IS ERROR LIKE TOM_JERRY, 
async function evaluateFormData(formData){
	"use server"
	.......
}

}

//Error From NextJs
Error: 
  × It is not allowed to define inline "use server" annotated Server Actions in Client Components.
  │ To use Server Actions in a Client Component, you can either export them from a separate file with "use server" at the top, or pass them down through props from a Server Component.
  │ 
  │ Read more: https://nextjs.org/docs/app/api-reference/functions/server-actions#with-client-components

Why does server Vs client error occur ?
This error of server Vs client occur because, NEXT.JS will lead to ambiguity, NextJs will not be able to separate the client and server side code in an effective manner.

How to resolve it ?
Move the server related actions to separate file, with first line as "use server"
//Inside server-actions.Js
"use server"

export async function shareMeal(){
}

NOTE: In short this is like writing mock server methods for client during Unit testing , but rather we are not mocking :)


#endregion  "use server"



#endregion Server Vs Client components

#region NextJs Hooks

#region usePathname https://nextjs.org/docs/app/api-reference/functions/use-pathname
 usePathname(): [import { usePathname } from "next/navigation"]
--> usePathname is a Client Component hook that lets you read the current URL's pathname.

How do you fetch data in NextJs app?
--> NextJs is both BE + FE 
--> So in FE or in REACT you use useEffect
--> NextJs by default renders components from BE, so it can directly access the data from the database ,


#endregion usePathname

error.js
--> error.js should be a client component
--> error.js primarily depends on page.js, error page is limited to any pages and nested pages within the boundaries of page.js its defined.
--> if error.js is defined on root then its ablicable to all the pages.

HTTP 404: Resource Not found
not-found.js :  This name is conventional , NextJs recognises this page if an invalid-route is encountered
--> not-found.js can be at gloabl level which covers all the routes and nested routes 
--> not-found.js can be at folder/granular level as well for specific cases.
NOTE: without not-found.js we would still get HTTP 404 error
--> Next.Js have a method called as "notFound() --> import {notFound} from next/navigation" This method will find the closest not-found.js or error.js page and renders it. It shortcircuits the component rendereing and shows not-found page.

#region useFormStatus() from 'react-dom'

https://react.dev/reference/react-dom/hooks/useFormStatus
--> should be used on Client-Side Component so decorate the component with "use client" 
syntax: 
const { pending, data, method, action } = useFormStatus();


#endregion useFormStatus() 'react-dom'

#region useFormState() from 'react-dom'
--> https://react.dev/reference/react-dom/hooks/useFormState
--> should be used on Client-Side Component so decorate the component with "use client" 
useFormState is similar to useState, syntax:

const [state, formAction] = useFormState(fn, initialState, permalink?);

Example

import { useFormState } from "react-dom";

//This is a server-action, in general if useFormState is NOT used this will be given in <form action={increment}/> 
async function increment(previousState, formData) { // previousState is supplied by useFormState
  return previousState + 1;
}

function StatefulForm({}) {
  const [state, formAction] = useFormState(increment, 0);
  return (
    <form>
      {state}
      <button formAction={formAction}>Increment</button>
    </form>
  )
}

Caveats 
The useFormStatus Hook must be called from a component that is rendered inside a <form>.
useFormStatus will only return status information for a parent <form>. It will not return status information for any <form> rendered in that same component or children components.

#endregion useFormState() 'react-dom'

#endregion NextJs Hooks

#region revalidatePath()

https://nextjs.org/docs/app/api-reference/functions/revalidatePath

Syntax: 
revalidatePath(path: string, type?: 'page' | 'layout'): void;

Example:
import { revalidatePath } from 'next/cache'
revalidatePath('/blog/post-1')

Scenario:
Consider during build process, NextJs creates a bundle for server deployment . During this point
NextJs agressively caches the pages where there is no client related involvement in component
But when we perform CRUD operations and redirect to cached pages the newly added/updated/deleted item will not be seen because cache data is not invalidated, the fetch opertaion will not be called due to caching... Now the solution is invalidate caching for specific pages where there is a fetch call  to server for that we use revalidatePath . revalidate accepts path and second param as either page(only url) or layout(url/nested url)

allows you to purge cached data on-demand for a specific path

'use server'
 
import { revalidatePath } from 'next/cache'
 
export default async function submit() {
  await submitForm()
  revalidatePath('/')
}


#endregion revalidatePath()

#region Metadata

Static Pages Metadata:
======================
In static pages metadata is added by the next.js if we supply the Metadata object as part of the root-layout  

//NOTE: THE NAME OF THE OBJECT MUST BE "metadata" ONLY
export const metadata = {
  title: 'NextLevel Food',
  description: 'Delicious meals, shared by a food-loving community.',
};

This metadata will be passed to subsequent children, until another "metadata" is found specific to page , in that case page "metadata" will take precedence

Dynamic Page Metadata: [slug]
==============================
In case of Dynamic pages Metadata will be generated when we include a method 

////NOTE: THE NAME OF THE METHOD MUST BE async and "generateMetadata" ONLY
"export async function generateMetadata({params})" 

The params object will give the dynamic url fragments , form there we can give a metadata object 

export async function generateMetadata({params}){
    const meal = getMeal(params?.slug)
    if (!meal) {         return notFound()     }
    return {
        title: meal.title,
        description: meal.summary
    }
}



#endregion Metadata


#endregion NextJs Concepts

#region Pages and File Based Routing

Code Snapshots :
https://github.com/mschwarzmueller/nextjs-course-code.

What is File Based Routing?
===========================
React uses routing from react-router , where we define routes and give components as as children ,
But In NextJs we give routes in a separate folder "/pages", NextJs will infer routes from that folder , without any JSX code at all. Routing is done based on convention.
Consider the following route paths in NextJs , 

/pages
	index.js // route: my-domain.com/ 
	about.js // route: my-domain.com/about
	/products
		index.js // route: my-domain.com/products
		[id].js	 // route: my-domain.com/products/1
	/blogs
		[...slug].js // ***route: my-domain.com/products

* empty path is index page by default , 
* [id].js is special type of dynamic routes , [id] here serves as a placeholder for url fragment.
*** catch-all routes, assume you want to search a blogpost over a period of time , in a year, in a month, on a specific date , etc  but consistently show the same page in that case we use catch all route nextJs notation for catch all route is [...slug].js 

How do you catch the dynamic  fragments of a route in your React component inside NextJs ?

we can use a special hook "useRouter" 
import { useRouter } from "next/router"
const router = useRouter()
In case of catch all routes , for Example all the fragments will be given as an array by router.query 
url used: http://localhost:3000/blog/2021/10/8
console.log(router.query) //slug: ["2021","10","8"]

Page Based Routing- NotFound page
=================================
NextJs looks for "404.js" if there is no matching route.

File-Based-Routing(FBR) Vs React-Based-Router(RBR) or Code-Based
==========================================================
--> FBR has no extra boilerplate code required, RBR setup in code required <Switch>,<Route>
--> FBR is intutive, by convention where as RBR is straight forwrd but includes new components and Concepts
--> FBR has File+folder structure(in pages/folder) influences routes, RBR File+folder doesn't matter at all




#endregion Pages and File Based Routing