Udemy : https://www.udemy.com/course/nextjs-react-the-complete-guide/learn/lecture/41160686#overview
Interview Questions: https://www.geeksforgeeks.org/next-js-interview-questions-answers2024/

#region How to create React-Template( CRA is obsolete)
As of React 18.0 and later, `create-react-app` is considered outdated and no longer the preferred method for bootstrapping a React application. Modern React tooling has shifted toward using more lightweight and flexible tools like `Vite`, `Next.js`, `Parcel`, or custom configurations with tools like Webpack. Below is how you can create a React application using modern tooling.

---

### 1. **Using Vite**
[Vite](https://vitejs.dev) is a fast development build tool that has become increasingly popular for creating modern React apps. It offers a much faster and more optimized development experience compared to `create-react-app`.

#### Steps to Create a React App with Vite:
```bash
# Step 1: Use the Vite CLI to scaffold a new project
npm create vite@latest my-react-app --template react

# Step 2: Navigate into the new project folder
cd my-react-app

# Step 3: Install the dependencies
npm install

# Step 4: Start the development server
npm run dev
```

#### Features of Vite:
- Lightning-fast startup and hot module reloading (HMR)
- Built-in support for modern JavaScript and React
- Excellent tree-shaking and optimized production builds

---

### 2. **Using Next.js**
[Next.js](https://nextjs.org) is a React framework suitable for both Single Page Applications (SPAs) and Server-Side Rendering (SSR) applications. It's a great choice for building scalable React apps with features like routing, API routes, and file-based structure out-of-the-box.

#### Steps to Create a React App with Next.js:
```bash
# Step 1: Use the Next.js CLI to scaffold a new project
npx create-next-app@latest my-next-app

# Step 2: Navigate into the new project folder
cd my-next-app

# Step 3: Start the development server
npm run dev
```

#### Features of Next.js:
- Built-in routing and API support
- Automatic code splitting and faster page loading with static generation or server-side rendering
- Supports React Server Components and other React 18 features
- Great for SEO optimization and highly scalable applications

---

### 3. **Using Parcel**
[Parcel](https://parceljs.org) is another simple choice for bundling React applications. It requires almost zero configuration to get started.

#### Steps to Create a React App with Parcel:
1. Create a new directory for your project, and initialize it:
   ```bash
   mkdir my-parcel-app
   cd my-parcel-app
   npm init -y
   ```
2. Install React, React DOM, and Parcel:
   ```bash
   npm install react react-dom parcel
   ```
3. Create your project folder structure:
   ```
   my-parcel-app/
   ├── src/
   │   └── index.html
   │   └── index.jsx
   └── package.json
   ```
4. Inside `src`:
   - Create an `index.html` file:
     ```html
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8" />
       <title>React App with Parcel</title>
     </head>
     <body>
       <div id="root"></div>
       <script type="module" src="index.jsx"></script>
     </body>
     </html>
     ```
   - Create an `index.jsx` file:
     ```jsx
     import React from 'react';
     import ReactDOM from 'react-dom';

     const App = () => <h1>Hello, React!</h1>;

     ReactDOM.createRoot(document.getElementById('root')).render(<App />);
     ```
5. Update your `package.json` to include a `start` script for Parcel:
   ```json
   "scripts": {
     "start": "parcel src/index.html",
     "build": "parcel build src/index.html"
   }
   ```
6. Run the development server:
   ```bash
   npm start
   ```

---

### 4. **Manually with Webpack or Rollup**
If you need full control over your setup, you can create a React app manually using Webpack or Rollup. While this approach is less beginner-friendly, it is sometimes preferred for advanced use cases.

---

### 5. **Use React's Official Template via `npx create-react-app` (If You Want)**:
Although `create-react-app` is outdated, it still works for basic examples:
```bash
npx create-react-app my-app
```

Keep in mind that `create-react-app` doesn't support advanced modern features and has slower builds compared to tools like Vite or Next.js.

---

### Recommendation:
For most modern React projects:
- Use **Vite** for fast development and production apps.
- Use **Next.js** for larger apps needing routing, SSR, or static site generation.
- Use **Parcel** or custom configurations for unique and simple setups.




#endregion

#region Javascript pre-render, pre-fetch, pre-generate, pre-load, async, defer


1. JavaScript Pre-render: Pre-rendering loads a webpage in the background before the user navigates to it. If you know that a user is likely to navigate to a certain page next, you can pre-render that page so it loads instantly when the user decides to visit it. 

Example: `<link rel="prerender" href="https://yourwebsite.com/page2.html">`

2. JavaScript Pre-fetch: Pre-fetching is similar to pre-rendering, but with a twist. It fetches the necessary files and data needed for the page before the user actually navigates to it.

Example: `<link rel="prefetch" href="https://yourwebsite.com/file.js">`

#region pre-render Vs pre-fetch
When optimizing your website for performance, understanding the difference between `pre-render` and `pre-fetch` helps you decide which process to use based on your website's needs.

**Pre-render**
`Pre-rendering` is a process where an entire webpage is rendered in the background before a user navigates to it, making it readily available as soon as it's requested. This can drastically improve perceived performance as the webpage appears to load instantly.

However, `pre-rendering` can be resource-intensive as it requires significantly more memory and CPU power, rendering the entire DOM in the background. This can be a problem if the end user doesn’t ever visit the pre-rendered page, leading to unnecessary use of resources.

An example of pre-render is: `<link rel="prerender" href="https://example.com/next-page.html">`

**Pre-fetch**
`Pre-fetching`, on the other hand, only downloads and stores the necessary resources (like JavaScript, CSS, and image files) for future use, without actually rendering the page. When a user navigates to a pre-fetched page, the browser has most, if not all, of the necessary resources and is able to render the page more quickly.

But unlike pre-rendering, it doesn't process or execute the downloaded files, resulting in a less obvious increase in page load speed, but uses less resources compared to pre-rendering.

An example of prefetch is: `<link rel="prefetch" href="https://example.com/next-page.html">`

Choosing between pre-rendering and pre-fetching will depend on the specific needs and resources of your website. If instant page load is a high priority and resources are plentiful, `pre-render` could be an appropriate choice. However, if resource usage is a concern, `pre-fetch` might be a better option.

#endregion pre-render Vs pre-fetch

3. JavaScript Pre-generate: This isn't a standard JavaScript attribute or method, but it generally refers to the concept of generating HTML, CSS, and JavaScript files at build time instead of run time.

4. JavaScript Pre-load: Preloading allows the browser to start loading resources early in the background, without rendering them, until they are needed. This is used for resources that are necessary for the page's first load.

Example: `<link rel="preload" href="https://yourwebsite.com/styles.css" as="style">`

#region Pre-load Vs pre-fetch
Preload and Prefetch are both directives to browsers sent via HTML or HTTP headers that can increase the performance of a page load. They have different ways and uses:

**Preload**
The `preload` value of the `link` tag's `rel` attribute lets you declare fetch requests in the HTML's `head`, specifying resources that your page will need very soon, which you want to start loading early in the lifecycle of a page, before browser's main rendering machinery kicks in. This way, they are available earlier and are less likely to block the page's render.

```html
<link rel="preload" href="style.css" as="style">
<link rel="preload" href="main.js" as="script">
```

`As` attribute is necessary to correctly setup the request and the correct content type.

**Prefetch**
The `prefetch` value of the `link` tag's `rel` attribute tells the browser to fetch resources in the background (low priority) that might be used in the navigation to the next page. This could be, for example, the JavaScript or CSS file for the next page.

```html
<link rel="prefetch" href="page2.js">
```

Unlike `preload`, `prefetch` does not block the `window.onload` event, meaning that prefetching has a lower priority than resources needed for the current page. 

In summary, `preload` is used to load resources that are needed right now, while `prefetch` is used more as a performance optimization for future navigations. Each one is better for different scenarios and they can be used together as well.

#endregion Pre-load Vs pre-fetch

5. JavaScript async: Async stands for “asynchronous” and is used when you want your scripts to load asynchronously alongside the rest of your web page, without blocking the parsing of the HTML document. 

Example: `<script src="script.js" async></script>`

6. JavaScript defer: Defer is used when you want your scripts to load in the background while the rest of your webpage loads and renders, but you want it to only execute after the page has been fully parsed. 

Example: `<script src="script.js" defer></script>`

#region async Vs defer

`async` and `defer` are two attributes that can be added to a script tag to change when the JavaScript file is executed. They're both useful for improving page load speed, but they have different use cases.

**Async**
The `async` attribute allows the browser to continue parsing the HTML document while the script is being downloaded. Once the script is downloaded, the HTML parsing is paused while the script is executed, and then resumed when the script has finished running. 

If you have multiple `async` scripts, they're executed in the order they were downloaded, which might not be the same as the order they're listed in the HTML.

This is useful when the script is independent from any others on the page and it doesn't alter the DOM (Document Object Model).

Example:
```html
<script async src="script.js"></script>
```

**Defer**
The `defer` attribute, meanwhile, also allows the browser to continue parsing the HTML document while the script is being downloaded, just like `async`. However, defer ensures that scripts are executed in the order they appear in the HTML document, and only after the HTML document has finished parsing.

This is useful when the script depends on other scripts or when it alters the DOM.

Example:
```html
<script defer src="script.js"></script>
```

In summary, both `async` and `defer` are used to prevent scripts from blocking the parsing of HTML. The key differences are that `async` will execute as soon as the script is available (potentially blocking the HTML parsing), whereas `defer` will maintain the order of scripts and ensure they're executed only after the entire HTML document has been parsed.

#endregion async Vs defer

Remember, all these tags and attributes help facilitate a more performant loading and rendering of your web application by allowing the browser to better prioritize its network requests and parsing of resources.

#endregion Javascript pre-render, pre-fetch, pre-generate, pre-load,async, defer

#region Getting Started

NextJs Docs: https://nextjs.org/docs

NextJs Vs React: https://radixweb.com/blog/nextjs-vs-react#difference



What is Next.Js? Its open source
https://radixweb.com/blog/nextjs-vs-react#difference
1) Next JS is a JavaScript framework that allows developers to create user-friendly and blazing fast static websites and static web applications with React. Next JS is an open-source, lightweight web development framework for React applications. It allows developers to build server-side rendering.

2) Next.js is based on React babel and webpack, which provides an out-of-the-box solution for server-side rendering (SSR) of React components

3) Next.js provides many features, such as static export, preview mode, pre-rendering, faster compilation, and automatic building size optimization.

What is Next.js Used for?
1) ECommerce Websites
2) Marketing Websites
3) Landing Pages


#region When to use NextJs and when to use ReactJs

Why do you need Next.Js when React is already there?

Next. Js Provides oUt-of-box support for 
Server-side Rendering (SSR)
Static Export (SSG)
Pre-rendering
Automatic Build Size Optimization
Enhanced Development Compilation
Route Setup and Handling
Form Submission
Data Fetching
Authentication.

Next.js provides many features, such as static export, preview mode, pre-rendering, faster compilation, and automatic building size optimization, automatic Code-splitting

What is Code-Splitting?
https://web.dev/learn/performance/code-split-javascript#:~:text=Code%20splitting%20is%20a%20useful,loaded%20at%20any%20other%20time.

Example:
document.querySelectorAll('#myForm input').addEventListener('blur', async () => {
  // Get the form validation named export from the module through destructuring:
  const { validateForm } = await import('/validate-form.mjs');

  // Validate the form:
  validateForm();
}, { once: true });


#region ChatGpt

Next.js and React.js both serve web development purposes, but they cater to different needs and use cases. React.js is a front-end library for building user interfaces, while Next.js is a full-fledged framework built on top of React.js that offers additional features like server-side rendering (SSR), static site generation (SSG), API routes, and more. Below, I compare the two and highlight situations in which you should use **Next.js** over vanilla React.js.

---

### **When to Use Next.js Instead of React.js**

1. **SEO (Search Engine Optimization) Requirements**
   - If your website or application needs to be SEO-friendly, Next.js is a better choice because it provides **server-side rendering (SSR)** and **static site generation (SSG)**. These features allow pages to be pre-rendered on the server or at build time, ensuring that search engines can crawl and index them efficiently.
   - React's default approach, client-side rendering (CSR), can make it hard for search engine bots to index dynamic or JavaScript-heavy pages.

   **Use Case Examples**:
   - Blogs.
   - News or magazine websites.
   - E-commerce websites with category pages.
   
   How does SEO works briefly?
     Find out the answer.

---

2. **Faster Page Loads (Improved Performance)**
   - Next.js can pre-render pages either statically (SSG) or dynamically (SSR), which significantly improves a website's performance. Pre-rendered pages load faster because the browser gets an HTML page directly from the server, rather than waiting for JavaScript to fetch and build the content.
   - Additionally, **image optimization** (`next/image`) is built into Next.js, which can further enhance performance.

   **Use Case Examples**:
   - Large-scale websites with lots of traffic.
   - Platforms where user retention is critical, such as e-commerce or SaaS applications.

---

3. **Need for Server-Side Rendering or Static Site Generation**
   - If your application relies on **real-time or fresh data fetched at every request**, SSR in Next.js ensures that users always see the most recent data. This is especially helpful for:
     - Displaying data that changes frequently.
     - Dynamic user content (e.g., a dashboard or user profile).
   - Alternatively, for content that remains static (e.g., marketing pages or product documentation), SSG can generate pages at build time for blazing-fast performance.

   **Use Case Examples**:
   - Real-time dashboards (SSR).
   - Marketing websites, product documentation, landing pages (SSG).

---

4. **Full-Stack Capabilities with API Routes**
   - Next.js has built-in support for creating API routes. You don't need a separate backend for small-scale or middle-tier server logic like forms handling, webhooks, or data fetching. This allows you to build **full-stack applications** with ease.

   **Use Case Examples**:
   - Contact forms.
   - Minimalist backends for front-end applications.
   - Prototyping full-stack applications.

---

5. **Increase Developer Efficiency and Workflow**
   - Next.js streamlines a lot of functionality that you would need to set up manually with React. Features like routing, code splitting, and API handling are all pre-configured or easy to implement in Next.js.
   - Unlike React, there’s **file-based routing** in Next.js. The folder and file structure in your project directly determines the routing, eliminating the need for libraries like `react-router`.

   **Use Case Examples**:
   - Rapidly building MVPs (Minimum Viable Products).
   - Projects where performance optimization isn't the main focus during the development phase.

---

6. **Dynamic Routing Made Simple**
   - In Next.js, you can easily implement **dynamic routes** by adding a file with a parameterized name in the `pages` directory (e.g., `[id].js`). This makes it very straightforward to create pages like `/users/:id` or `/products/:slug`.

   **Use Case Examples**:
   - Social media feeds.
   - Product detail pages.

---

7. **Incremental Static Regeneration (ISR)**
   - Next.js supports **ISR**, which allows you to update statically generated pages after the build without having to rebuild the entire application. This is helpful for applications with frequently changing content but lower deployment constraints.

   **Use Case Examples**:
   - Blogs.
   - Product catalogs with periodic updates.

---

8. **Internationalization (i18n)**
   - With Next.js, you get built-in support for internationalization (i18n), which makes it easier to handle multi-language websites or applications.

   **Use Case Examples**:
   - Content-heavy multilingual websites.
   - Global e-commerce platforms.

---

9. **Optimized for Deployment**
   - Next.js is tightly integrated with hosting platforms like **Vercel** (creators of Next.js) and supports tools like serverless functions and CDN caching. This makes deployment easier compared to manually setting up CI/CD pipelines for React projects.

   **Use Case Examples**:
   - Deploying websites with minimal setup effort.
   - Leveraging serverless architecture for scalable apps.

---

10. **Progressive Web App (PWA) and Hybrid Applications**
    - Next.js makes it easier to build hybrid applications (mixing SSR, SSG, and CSR) in scenarios where some parts of the app need server-side rendering (e.g., blogs) and others need client-side interaction (e.g., dynamic dashboards).
    - It’s also easier to configure Progressive Web Applications (PWAs) in Next.js.

    **Use Case Examples**:
    - Web apps with a mix of dynamic and static content.
    - PWAs for mobile-first applications.

---

### **Why Would You Choose React Over Next.js?**

While Next.js is a great framework, there are scenarios where React.js may be the better choice:

1. **Simpler Applications**
   - If your application doesn’t require features like SSR, SSG, or API routing, and is straightforward (e.g., single-page apps), React may be sufficient.
   - Example: A small personal portfolio, single-page interactive components.

2. **Learning Basics**
   - If you’re starting out with front-end development, learning React first is recommended. Next.js builds on top of React, so understanding React’s fundamentals is crucial.

3. **When SSR/SSG isn't Required**
   - If all your application logic and data fetching occur on the client side, SSR/SSG may not provide much value.

4. **Custom Configurations**
   - Next.js comes with a lot of pre-configured tools, but if you need full control over your build process, routing, and other configurations, React (combined with tools like Webpack) may give more flexibility.

5. **SPA-First Applications**
   - If you’re building a single-page app (SPA) with minimal SEO needs and no SSR/SSG, React alone is lighter, simpler, and more performant.

---

### **Conclusion**

Use **Next.js** when you need:
- Server-side rendering (SSR) or static site generation (SSG).
- SEO optimizations.
- Pre-rendered dynamic or static content.
- File-based routing and a more streamlined workflow.
- API routes or a small backend.

Use **React.js** when:
- You’re building simpler, single-page apps (SPA) or fully client-rendered apps.
- You need fine-grained control over the tooling and configuration.
- You’re just starting out and focusing on mastering the core concepts of React.

If you foresee the need for scalability and additional features in the future, Next.js can save development time, and it’s worth considering it from the start!

#endregion ChatGpt

#endregion When to use NextJs and when to use ReactJs

#endregion 

#region NextJs Interview Questions


NextJs can be used to build :
Several types of websites and applications can be built. But the most popular are-
Desktop websites
Static websites
Server rendered applications
SEO friendly websites
Progressive web applications (PWA)

What is meant by Styled JSX in Next JS?
We use this CSS-in-JS library for writing encapsulated and scoped CSS for styling Next JS components. No other component gets affected by introducing the styles to a component using Styled JSX. This allows adding, changing, and deleting the styles without any complications.

Is Next JS backend, frontend, or full-stack?
Next JS is full-stack. This means that it allows rendering client-side as well as server-side content. And this is the reason it is highly valued on React, as React allows only frontend development without it.

Next JS provides two types of pre-rendering- Server-side rendering and Static rendering.
Static Generation- It generates the HTML at build time, and we can reuse it on each request. It is the recommended one of the two. For using Static generation, either the page component has to be exported or 'getStaticProps'

Server-side rendering- It generates the HTML on each request. For using Server-side rendering, 'getServerSideProps' has to be exported.

NOTE: By default, Static Generation is the pre-render available in Next JS without any data fetched

What are the most important features introduced in Next.js 12.1?
The most important features are given below-
New Rust-based compiler
Faster image optimization
On-demand incremental static regeneration (Beta)
Self-hosted Next JS improvements
Zero-configuration Jest plugin
React 18 support

Which key features are provided by Next JS in terms of SEO?
The following perks are there-

Jamstack compatibility
Increased flexibility in designing the UX of our website
Automatic static optimization
Improved data security
Fast static websites
Responsiveness and adaptability

List some competitors and alternatives to Next JS.
Some alternatives to Next JS are listed below-

Gatsby
React
Create React App
Hexo
Hugo
LoopBack
Angular Universal
React Router

What are CSS Modules?
https://css-tricks.com/css-modules-part-1-need/
https://nextjs.org/docs/app/building-your-application/styling/css-modules
CSS Modules locally scope CSS by automatically creating a unique class name. This allows you to use the same class name in different files without worrying about collisions. This behavior makes CSS Modules the ideal way to include component-level CSS.


#endregion NextJs Interview Questions

#region NextJs Concepts 

#region PageRouter Vs AppRouter
================================
https://www.freecodecamp.org/news/routing-in-nextjs/#:~:text=A%20key%20difference%20between%20the,routes%20within%20the%20app%20folder.

The Pages Directory automatically creates routes within the pages folder, whereas the App Router organizes routes within the app folder

From ChatGPT: https://chat.lab.epam.com/
These routing models differ in terms of how they organize code and handle routing logic

1. Page-Based Routing: 
=====================
Page-based routing in Next.js is file-system based. Every file inside the `pages` directory becomes a route automatically.
This way, you don't have to maintain a separate routing configuration file, and the file organization itself determines the URLs.
For example, if you create a file at `pages/about.js`, it will be accessible at `your-website/about`.
NOTE: PAGES DIRECTORY SHOULBE BE THERE TO CREATE ROUTES 

Example "pages/about.js":

```jsx
function About() {
  return <div>About</div>
}

export default About
```

Here, About function in `about.js` will be served when `/about` is requested.


App Router:
============


REACT router-dom-based Routing:
===============================
App-based routing provides more flexibility than page-based routing and is often used for applications with complex routing requirements, such as nested routes or dynamic routes. 
With app-based routing, you'll configure your routes manually in a central location (e.g., `app.js` or `routes.js`). This model gives you fine-grained control over routing and lets you take advantage of libraries such as react-router-dom.

Example "app.js":

```jsx
import React from "react";
import { BrowserRouter as Router, Route, Switch } from "react-router-dom";
import About from "./pages/About";
import Home from "./pages/Home";

function App() {
  return (
    <Router>
      <Switch>
        <Route path="/about">
          <About />
        </Route>
        <Route path="/">
          <Home />
        </Route>
      </Switch>
    </Router>
  );
}

export default App;
```
With this approach, if you ever decide to change URL structure, you'd have to refactor your app routing file.

To summarize, if you’re building a simple website with straightforward navigation, the automatic, page-based routing provided by Next.js may save you some time. Alternatively, for more complex applications, manually routing using an app-based approach may provide the flexibility you need.

#endregion PageRouter Vs AppRouter

#region Reserverd Names in Next.js
Here's a list of reserved filenames in NextJS - you'll, of course, learn about the important ones throughout this section:

page.js => Create a new page (e.g., app/about/page.js creates a <your-domain>/about page)

layout.js => Create a new layout that wraps sibling and nested pages

not-found.js => Fallback page for "Not Found" errors (thrown by sibling or nested pages or layouts)

error.js => Fallback page for other errors (thrown by sibling pages or nested pages or layouts)

loading.js => Fallback page which is shown whilst sibling or nested pages (or layouts) are fetching data

route.js => Allows you to create an API route (i.e., a page which does NOT return JSX code but instead data, e.g., in the JSON format)

#endregion Reserverd Names in Next.js

#region <Link> in Next.Js

import Link from "next/Link"

https://nextjs.org/docs/pages/api-reference/components/link
<Link> is a React component that extends the HTML <a> element to provide prefetching and client-side navigation between routes. It is the primary way to navigate between routes in Next.js.

What is Prefetch? 
https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching
Prefetching is a way to preload a route in the background before the user visits it.

What is Dynamic Routing?
https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes
When you don't know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time or prerendered at build time

What is Prerendering?
https://nextjs.org/docs/pages/building-your-application/rendering
By default, Next.js pre-renders every page. This means that Next.js generates HTML for each page in advance, instead of having it all done by client-side JavaScript. Pre-rendering can result in better performance and SEO. Each generated HTML is associated with minimal JavaScript code necessary for that page.

#endregion <Link>

#region <Image> in Next.js

Html <img> Vs NextJs <Image> ?
https://nextjs.org/docs/app/api-reference/components/image
https://nextjs.org/docs/app/building-your-application/optimizing/images

html : <img src={logo.src} alt="Food served on Plate" />
NextJs: <Image src={logo} alt="Food served on Plate" />

The Next.js Image component extends the HTML <img> element with features for automatic image optimization:

Size Optimization: Automatically serve correctly sized images for each device, using modern image formats like WebP and AVIF.
Visual Stability: Prevent layout shift automatically when images are loading.
Faster Page Loads: Images are only loaded when they enter the viewport using native browser lazy loading, with optional blur-up placeholders.
Asset Flexibility: On-demand image resizing, even for images stored on remote servers

"Priority" prop on <Image>:  this prop is added to tell the Image component to not load using lazy loading, thus avoiding the flickering effect

#endregion <Image>

#region Css and Styling in Next.Js
What are various CSS Styles followed in Next.Js?
https://nextjs.org/docs/app/building-your-application/styling

What is Css-in-Js?
https://blog.logrocket.com/css-vs-css-in-js/

#endregion Css and Styling in Next.Js

#region ****Server Vs Client Components


Scenario: assume we have a React component(SlideShow) that needs to be displayed on the Next.Js Page route 
When you careate the compnent and try to render the component we see an error saying 
ERROR MESSAGE: You're importing a component that needs useEffect. It only works in a Client Component but none of its parents are marked with "use client", so they're Server Components by default.
Learn more: https://nextjs.org/docs/getting-started/react-essentials

Answer: That difference is there in React itself Vanilla React appas is a client library, that render components on the client. Where as Next.Js is a full stack app(Server side + Client-Side) Which means code executes in the Backend
--> Backend executes the server component functions and hence derives the to-be-rendered HTML
--> The client side recieves and renders the to-be-rendered HTML
Hence in the nextJs apps on backend side the react isn't understandable , its not recognized

This is the advantage of Next-Js because of Less client-side JS, great for SEO.
Websearch crawlers will now see the complete finished content , chances are that your website will be ranked high.


#region "use server" directive
But How do we render the client-side-react components in NextJs ?
Answer: We need to use 'use client' directive on the react components that needs to be rendered on the client side, Next Js pre-renders the pages, but react component can be opted in using "use client"
In Backend of NextJs, the code doesn't understand what is useState, useReact and other hooks
In Backend of NextJs, the code doesn't understand what the evenets like onClick, onHover and other events they are browser events 
To 

** Always separate the client components, even though they are small parts.
**Maximise the use of server rendering supported by NextJs.

How do you execute a specific functionality on server side ?
"use server" : This will enable a specific functionality or funtion to be executed on Server

//The below function is guranteed to execute on the server
//To really turn this action into server action we need to add "async" //keyword
//If async is missed Error: Server actions must be async functions
async function shareMeal(){
	"use server"
	.......
}

consider a <form onSubmit={handleSubmit}> element in general this 
is the way we design forms on client side where on handleSubmit will send the formData to backend, but when we are rendering this from backend itself , How do we achieve it 
--> We achieve it using <form action={evaluateFormData}/> in this case the "use server" will be used .
//The below function is guranteed to execute on the server
//To really turn this action into server action we need to add "async" //keyword
//If async is missed Error: Server actions must be async functions
async function evaluateFormData(formData){
	"use server"
	.......
}
--> action method in HTML5 is used to give the "post endpoint", in NextJs its been customised to give the server function, this is available out of the box.

What will happen If my component is rendered on client("use client"), and I want to do "use server"
Example:
"use client"
//Client Component
Client_Comp{

//NOTE: THIS IS ERROR LIKE TOM_JERRY, 
async function evaluateFormData(formData){
	"use server"
	.......
}

}

//Error From NextJs
Error: 
  × It is not allowed to define inline "use server" annotated Server Actions in Client Components.
  │ To use Server Actions in a Client Component, you can either export them from a separate file with "use server" at the top, or pass them down through props from a Server Component.
  │ 
  │ Read more: https://nextjs.org/docs/app/api-reference/functions/server-actions#with-client-components

Why does server Vs client error occur ?
This error of server Vs client occur because, NEXT.JS will lead to ambiguity, NextJs will not be able to separate the client and server side code in an effective manner.

How to resolve it ?
Move the server related actions to separate file, with first line as "use server"
//Inside server-actions.Js
"use server"

export async function shareMeal(){
}

NOTE: In short this is like writing mock server methods for client during Unit testing , but rather we are not mocking :)


#endregion  "use server"



#endregion Server Vs Client components

#region NextJs Hooks

#region usePathname https://nextjs.org/docs/app/api-reference/functions/use-pathname
 usePathname(): [import { usePathname } from "next/navigation"]
--> usePathname is a Client Component hook that lets you read the current URL's pathname.

How do you fetch data in NextJs app?
--> NextJs is both BE + FE 
--> So in FE or in REACT you use useEffect
--> NextJs by default renders components from BE, so it can directly access the data from the database ,


#endregion usePathname

error.js
--> error.js should be a client component
--> error.js primarily depends on page.js, error page is limited to any pages and nested pages within the boundaries of page.js its defined.
--> if error.js is defined on root then its ablicable to all the pages.

HTTP 404: Resource Not found
not-found.js :  This name is conventional , NextJs recognises this page if an invalid-route is encountered
--> not-found.js can be at gloabl level which covers all the routes and nested routes 
--> not-found.js can be at folder/granular level as well for specific cases.
NOTE: without not-found.js we would still get HTTP 404 error
--> Next.Js have a method called as "notFound() --> import {notFound} from next/navigation" This method will find the closest not-found.js or error.js page and renders it. It shortcircuits the component rendereing and shows not-found page.

#region useFormStatus() from 'react-dom'

https://react.dev/reference/react-dom/hooks/useFormStatus
--> should be used on Client-Side Component so decorate the component with "use client" 
syntax: 
const { pending, data, method, action } = useFormStatus();


#endregion useFormStatus() 'react-dom'

#region useFormState() from 'react-dom'
--> https://react.dev/reference/react-dom/hooks/useFormState
--> should be used on Client-Side Component so decorate the component with "use client" 
useFormState is similar to useState, syntax:

const [state, formAction] = useFormState(fn, initialState, permalink?);

Example

import { useFormState } from "react-dom";

//This is a server-action, in general if useFormState is NOT used this will be given in <form action={increment}/> 
async function increment(previousState, formData) { // previousState is supplied by useFormState
  return previousState + 1;
}

function StatefulForm({}) {
  const [state, formAction] = useFormState(increment, 0);
  return (
    <form>
      {state}
      <button formAction={formAction}>Increment</button>
    </form>
  )
}

Caveats 
The useFormStatus Hook must be called from a component that is rendered inside a <form>.
useFormStatus will only return status information for a parent <form>. It will not return status information for any <form> rendered in that same component or children components.

#endregion useFormState() 'react-dom'

#region useRouter
If you want to access the router object inside any function component in your app, you can use the useRouter hook
https://nextjs.org/docs/pages/api-reference/functions/use-router

Example:
import { useRouter } from 'next/router'
 
function ActiveLink({ children, href }) {
  const router = useRouter()
  const style = {
    marginRight: 10,
    color: router.asPath === href ? 'red' : 'black',
  }
 
  const handleClick = (e) => {
    e.preventDefault()
    router.push(href)
  }
 
  return (
    <a href={href} onClick={handleClick} style={style}>
      {children}
    </a>
  )
}
 
export default ActiveLink

#endregion useRouter

#endregion NextJs Hooks

#region revalidatePath()

https://nextjs.org/docs/app/api-reference/functions/revalidatePath

Syntax: 
revalidatePath(path: string, type?: 'page' | 'layout'): void;

Example:
import { revalidatePath } from 'next/cache'
revalidatePath('/blog/post-1')

Scenario:
Consider during build process, NextJs creates a bundle for server deployment . During this point
NextJs agressively caches the pages where there is no client related involvement in component
But when we perform CRUD operations and redirect to cached pages the newly added/updated/deleted item will not be seen because cache data is not invalidated, the fetch opertaion will not be called due to caching... Now the solution is invalidate caching for specific pages where there is a fetch call  to server for that we use revalidatePath . revalidate accepts path and second param as either page(only url) or layout(url/nested url)

allows you to purge cached data on-demand for a specific path

'use server'
 
import { revalidatePath } from 'next/cache'
 
export default async function submit() {
  await submitForm()
  revalidatePath('/')
}


#endregion revalidatePath()

#region Metadata

Static Pages Metadata:
======================
In static pages metadata is added by the next.js if we supply the Metadata object as part of the root-layout  

//NOTE: THE NAME OF THE OBJECT MUST BE "metadata" ONLY
export const metadata = {
  title: 'NextLevel Food',
  description: 'Delicious meals, shared by a food-loving community.',
};

This metadata will be passed to subsequent children, until another "metadata" is found specific to page , in that case page "metadata" will take precedence

Dynamic Page Metadata: [slug]
==============================
In case of Dynamic pages Metadata will be generated when we include a method 

////NOTE: THE NAME OF THE METHOD MUST BE async and "generateMetadata" ONLY
"export async function generateMetadata({params})" 

The params object will give the dynamic url fragments , form there we can give a metadata object 

export async function generateMetadata({params}){
    const meal = getMeal(params?.slug)
    if (!meal) {         return notFound()     }
    return {
        title: meal.title,
        description: meal.summary
    }
}



#endregion Metadata

#region Debug NextJs
https://nextjs.org/docs/pages/building-your-application/configuring/debugging

#endregion Debug NextJs

#region Pages and File Based Routing

Code Snapshots :
https://github.com/mschwarzmueller/nextjs-course-code.

What is File Based Routing?
===========================
React uses routing from react-router , where we define routes and give components as as children ,
But In NextJs we give routes in a separate folder "/pages", NextJs will infer routes from that folder , without any JSX code at all. Routing is done based on convention.
Consider the following route paths in NextJs , 

/pages
	index.js // route: my-domain.com/ 
	about.js // route: my-domain.com/about
	/products
		index.js // route: my-domain.com/products
		[id].js	 // route: my-domain.com/products/1
	/blogs
		[...slug].js // ***route: my-domain.com/products

* empty path is index page by default , 
* [id].js is special type of dynamic routes , [id] here serves as a placeholder for url fragment.
*** catch-all routes, assume you want to search a blogpost over a period of time , in a year, in a month, on a specific date , etc  but consistently show the same page in that case we use catch all route nextJs notation for catch all route is [...slug].js 

How do you catch the dynamic  fragments of a route in your React component inside NextJs ?

we can use a special hook "useRouter" 
import { useRouter } from "next/router"
const router = useRouter()
In case of catch all routes , for Example all the fragments will be given as an array by router.query 
url used: http://localhost:3000/blog/2021/10/8
console.log(router.query) //slug: ["2021","10","8"]

Page Based Routing- NotFound page
=================================
NextJs looks for "404.js" if there is no matching route.

File-Based-Routing(FBR) Vs React-Based-Router(RBR) or Code-Based
==========================================================
--> FBR has no extra boilerplate code required, RBR setup in code required <Switch>,<Route>
--> FBR is intutive, by convention where as RBR is straight forwrd but includes new components and Concepts
--> FBR has File+folder structure(in pages/folder) influences routes, RBR File+folder doesn't matter at all




#endregion Pages and File Based Routing

#region Page Re-rendering and Data fetching
NextJs is not Just about Routing...

https://nextjs.org/docs/pages/building-your-application/data-fetching/get-static-props

Page Pre-rendering:
------------------
ROUTE : Request --> /first-route 

RESPONSE BY REACT :
<html>
<head></head>
<body>
<div id="root></div>
<script src="blah/blah/bundle.js"/>
</body> </html>

RESPONSE BY NEXT.JS:
<html>
<head></head>
<body>
<div id="root>
1) Item 1
2) Item 2
3) Item 3
</div>
<script src="blah/blah/bundle.js"/>
</body> </html>

Assume you are sending a FIRST request to a ROUTE,

In REACT the http request will give the RESPONSE BY REACT , empty html with placeholder and scripts
This is not good for Search Engine Optimization . To Improve the SEO, we need to PRE-RENDER the page with data 

***NOTE: Its good to know How SEO works briefly

Next.Js exactly does the same, NextJs pre-renders the page with suitable data(RESPONSE BY NEXT.JS), The search engines can index your page based on the data that is available on the pre-rendered page, This is only for first request. This is good for SEO. Once the page is rendered , this has to bind with React framework on the frontend/browser, this process is called as "HYDRATION".   ONce NextJs is loaded, Hydration takes place, React framework takes over and works as is.

By default Next.Js pre-renders all your pages by default, to check this render some conent and check "View Page Source" in chrome all the data is pre-rendered from server . 

Two types of Pre-Rendering in NEXT.Js
1) Static Generation:
2) Server Side rendering

Static Generation :
-------------------
--> Pre-generate a page(with data prepared on server-side) during build-time(CI/CD Build Step). Here Build Time means CI/CD during that process BUILD STEP(npm build)--> DEPLOY STEP
--> Then these pages are cached by server/served to CDN serving the app.

For pre-genarting a page, NExtJs automatically calls 
//Written on individual component level
export async function getStaticProps(context){
return { props:{}} //returns Object with props 
}

These props will be made available to the component in which getStaticProps have been implemented.

What does context have?
--> Context contains, execute times, locals, dynamic path values etc.

This method contains all the script/code/html to build the pre-rendered page, this method works on server side hence you will not have access to window object, Browser API's like setTimeout, Fetch, GeoLoacation, local/session storage, Audio/Video APIS, DOM API etc.


If you have static content on your page, no dynamic data attached to it , such pages are static pages(Welcome-On-board pages, Thank you pages, Intro-pages, blogs, articles etc) such type of pages are Static Pages, right candidates for Static Generation. SEO, Data available right from start to your end-users are advantages.

Incremental Static Generation:(ISG):
So the prerendered page will be built during the build step , what if the pre-rendered data is stale, to handle that case NextJs have two options

Way 1: Introduce useEffect Inside the componenet that is been pre-rendered , so that after first render which is filled with data from server , useEffect will run and fetch the data.

Way 2: Is Incremental Static Generation 
export async function getStaticProps(context) {
  const pathName = path.join(process.cwd(), 'data', 'dummy-data.json')
    const productsData = await fs.readFile(pathName)
  const parsedProds = JSON.parse(productsData)

  return {
    props: { products: parsedProds.products },
    revalidate: 60, //The revalidate option indicates //incremental static generation 
	 notFound: false // if set to true ,the given page is not found,  a 404 Page is returned 
	 redirect: {destination: '/no-data'}//Can also redirect from getStaticProps
  }
 }
 
The prop with revalidation takes 60s , after which for every request the build step takes automatically by nextJs and pre-renders the page .
NextJs  runs getStaticProps code during npm run build step 
  
Scenario : When you do the following in Product-Detail Page... ProductDetail Page is a dynamic page-->[pid].js

dummy-data:
{
  "products": [
    { "id": "p1", "title": "Product 1", "description": "This is product 1" },
    { "id": "p2", "title": "Product 2", "description": "This is product 2" },
    { "id": "p3", "title": "Product 3", "description": "This is product 3" }
  ]
}
//Inside [pid].js
const ProductDetailPage = (props) => {      return <h2>Product Detail Page of....</h2> } 
export default ProductDetailPage

export async function getStaticProps(context) {
    const { params } = context
    const pathName = path.join(process.cwd(), 'data', 'dummy-data.json')
    const productsData = await fs.readFile(pathName)
    const parsedProds = JSON.parse(productsData)
    const items = parsedProds.filter(item => item.id === params.pid)
    return {         props: { items }     }  }

//end Inside [pid].js

Output: Server Error
Error: getStaticPaths is required for dynamic SSG pages and is missing for '/[pid]'.
Read more: https://nextjs.org/docs/messages/invalid-getstaticpaths-value

Why do we see this server error?
================================
--> NextJs Pre-generate the static pages, but product-detail.js is a dynamically generated page [pid].js
--> Which means by default NextJs doesn't pre-generate dynamic pages , NextJs wouldn't know for how many pages it should pre-generate because pid's can be 1 or 2 or 1000, hence logically its not possible to pre-generate and pre-render using getStaticProps(context)

How do we solve this issue?
===========================
We can solve this issue by keeping NextJs informed about which part of the data will be used to generate the dynamic-paths(routes) for eg: in this case its product-id[pid] , and to keep NextJs informed about this dynamic fragment we have another method called 
export async function getStaticPaths() which will be used to pre-generate paths(routes) . The same is mentioned in the error message above .
Eg: 
//Inside [pid].js beneath getStaticProps()
//getStaticPaths will be executed first will pass the //execution to getStaticProps and then react.component
export async function getStaticPaths() {
//We should give the fragments on which dynamic pages will
//be generated in advance in below format
//You can also generate the data structure using Javascript code.
   return {
        paths: [
            {params:{pid:'1'}},
			{params:{pid:'2'}},
			{params:{pid:'3'}},
        ],
        fallback: false|true|'blocking'
    }
}

What is the usage of fallback?
--> if fallback is FALSE , all the pages for params are pre-generated by NextJs , When we switch to the product detail, a fetch call goes to p1.json and the data is loaded without any intervention from client-side, its all taken care by NextJs
--> if fallback is TRUE, assume pid's can 1 or 2 or 1000  pre-genarting 1000's of page is a overkill even on server 
		so from getStaticPaths() generate pre-rendered page only for few values like below generate only for params 1, which might be frequently accessed 
		export async function getStaticPaths() {
				return {
					paths: [{params:{pid:'1'}}],
					fallback: true,
		}
In this case, the pid2, and pid3 are not pre-generated, You can check that by directly typing in the URL because fallback is true . You will see an error in the React component if you haven't written any fallback code . I Fallback code is written then the request is sent to backend to load the p2 or p3 page which is not pre-rendered or pre-generated.
const ProductDetailPage = ({ item }) => {
//FALLBACK CODE, Below If condition is fallback code.
    if (!item) { return <h2>Loading....</h2>  }
    return (
        <>
            <h2>{item.title}</h2>
            <h3>{item.description}</h3>
        </>
    )
}

-->if fallback:'blocking' , If fallback is blocking you don't need to specify the fallback code in the product-detail componnent, The nextJs will automatically fetch the requested Resources
const ProductDetailPage = ({ item }) => {
    return (
        <>
            <h2>{item.title}</h2> <h3>{item.description}</h3> 
        </>
    )
}

What if you are querying for a product which doesn't exisit?
In that case :
--> fallback: true
--> Product-detail component should have fallback code
--> in getStaticProps if the product is non-existent instead of returning props, return {notFound:true} , this will render a notFound404 page by NextJs
export async function getStaticProps(context) {
    const { params } = context
    const products = await parseData()
    const item = products?.find(item => item.id === params.pid)
    if (!item) { return { notFound: true }}
    return {props: { item }}
}

***How do you know if Pages are statically generated or ISG(incremental static gen.) or SSG(Server Side Gen) is used during dev time?
====================================================================================
Way 1: 
To know that you can run "npm build", this will give all the stats like below 
 ✓ Generating static pages (6/6)
 ✓ Collecting build traces
 ✓ Finalizing page optimization

Route (pages)                              Size     First Load JS
┌ ● /                                      2.66 kB          82 kB
├   /_app                                  0 B            79.3 kB
├ ● /[pid] (438 ms)                        312 B          79.6 kB
├   ├ /p1
├   ├ /p2
├   └ /p3
└ ○ /404                                   180 B          79.5 kB
+ First Load JS shared by all              79.5 kB
  ├ chunks/framework-0c7baedefba6b077.js   45.4 kB
  ├ chunks/main-c379b48138cf9870.js        32.9 kB
  ├ chunks/pages/_app-2ba67b4e2e44dba9.js  294 B
  ├ chunks/webpack-fd8027ecb5121007.js     770 B
  └ css/49861c0d8668ac82.css               186 B

○  (Static)  automatically rendered as static HTML (uses no initial props)
●  (SSG)     automatically generated as static HTML + JSON (uses getStaticProps)    

Way 2:
There is ".next" folder there we can see the all the generated pages at .next/server/pages folder.

***NOTE: When you write console.log() in getStaticProps() the statments will be logged during build-step itself

Server Side Rendering: getServerSideProps()
=============================================
Now assume a scenario , where you need access to complete request object , or access to cookies or headers . In this case
--> getStaticPaths and getStaticProps cannot be used because they are been called at the time of BUILD STEP, even if use ISG(incremnetal Static Generation) still that might be called at iterating builds 
--> You get request object when the route is rendered or during Navigation during that point of time we might get Request Object, So NEXTJS gives us getServerSideProps() whenever a request reaches the server getServerSideProps() gets executed.

--> **NOTE: YOU CAN EITHER USE getStaticPaths/getStaticProps OR getServerSideProps().
YOU CANNOT USE BOTH AT A TIME. THEY RUN AT DIFFERENT TIMES.

Return types of getServerSideProps()
=====================================
async getServerSideProps(context){
const {params,headers,req,res, ...rest} = context

return {props: {}}
return {notFound:true}
return {redirect: {destination:'/some-path'}} //Absolute-path
//NO REVALIDATE IN getServerSideProps, it will always run on every request
}

How do you use getServerSideProps() with dynamic page like [uid].js?
====================================================================

export async function getServerSideProps(context){
const {params} = context
return {
	props:{
		userid: params.uid
	}
  }
}

When you run npm run build , you can see 

✓ Linting and checking validity of types
 ✓ Creating an optimized production build    
 ✓ Compiled successfully
 ✓ Collecting page data    
 ✓ Generating static pages (5/5)  // ONLY 5 PAGES are PRE_GENERATED, except                                 // userProfile
 ✓ Collecting build traces
 ✓ Finalizing page optimization

Route (pages)                              Size     First Load JS
┌ ● /                                      2.66 kB          82 kB
├   /_app                                  0 B            79.3 kB
├ ● /[pid]                                 329 B          79.6 kB
├   └ /1
├ ○ /404                                   180 B          79.5 kB
└ λ /userProfile                           274 B          79.6 kB
+ First Load JS shared by all              79.5 kB
  ├ chunks/framework-0c7baedefba6b077.js   45.4 kB
  ├ chunks/main-c379b48138cf9870.js        32.9 kB
  ├ chunks/pages/_app-2ba67b4e2e44dba9.js  294 B
  ├ chunks/webpack-fd8027ecb5121007.js     770 B
  └ css/49861c0d8668ac82.css               186 B

λ  (Server)  server-side renders at runtime (uses getInitialProps or getServerSideProps)     
○  (Static)  automatically rendered as static HTML (uses no initial props)
●  (SSG)     automatically generated as static HTML + JSON (uses getStaticProps)

***NOTE: When you write console.log() in getServerSideProps() the statments will be logged during route is rendered

Client-side Data Fetching using NextJs
=======================================
stock-Data pre-rendering , pre-fetching will not make much sense 


#endregion Page Re-rendering and Data fetching

#endregion NextJs Concepts

#region Links
https://hackernoon.com/30-nextjs-interview-questions-get-ready-for-your-dream-job
https://mindmajix.com/next-js-interview-questions

<a href> Vs <Link href=/>
=========================
With anchor tag, there is a new http request sent to theserever to fetch the page , which means stateless, all the state in redux/context will be lost 
With <Link>  this is client side routing happens , HTTP request is not sent to the server. app state is not lost.
Automaticall pre-fetches the data , pages that we might need are eagerly downloaded.

There are two ways of configuring a route in the <Link>
const client = [
        { id: 'ajay', name: 'AjayNallanagula' },
        { id: 'Divya', name: 'DivyaNallanagula' }
    ]
 client.map(route => <li key={route.id}>
 //WAY 1: 
                <Link href={`/client/${route.id}`}>{route.name}</Link> 
				
			//WAY 2
                <Link href={{
                    pathname: '/client/[id]',
                    query: { id: route.id }
                }}>{route.name}</Link>
            </li>



Incase If you need to navigate progamatically :
const router = useRouter()
    console.log('ClientId', { router })
    const handleNavigate = () => {
        router.push('/client/max/routeOnClick')
    }

#endregion Links
